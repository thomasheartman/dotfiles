#+BEGIN_SRC emacs-lisp :comments no :tangle yes
  ;; -*- lexical-binding: t; -*-
#+END_SRC

#+TITLE: Heartmacs
#+PROPERTY: header-args :results silent :tangle yes :comments both :noweb yes
#+PROPERTY: header-args:emacs-lisp+ :lexical t
#+TAGS: keybinding | { os : macos | linux } | GTD
#+todo: TODO(t@) | DONE(d!)


* Toggle debug
:PROPERTIES:
:header-args: :tangle no
:END:

When having issues, set this to ~:tangle yes~
#+BEGIN_SRC emacs-lisp
  (setq debug-on-error t)
#+END_SRC

If you need to figure out when a variable is modified, try using the
following snippet:
#+BEGIN_SRC emacs-lisp
  (debug-on-variable-change 'ido-mode)
#+END_SRC


* Package setup

** Package archives

I'll sometimes want to use local packages. I'll put them in a
directory local to my emacs config:
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path
               (expand-file-name
                "elisp"
                'user-emacs-directory))
#+END_SRC

* General
:PROPERTIES:
:REPO:     https://github.com/noctuid/general.el
:END:

General simplifies key binding.
#+BEGIN_SRC emacs-lisp
  (use-package general
    :config
    (general-auto-unbind-keys))
#+END_SRC

** Prefixes
:LOGBOOK:
- State "TODO"       from "TODO"       [2020-12-15 Tue 15:02] \\
  Rewrite this using macros to avoid repetitions.
- State "TODO"       from              [2020-08-14 Fri 21:25]
:END:

Similarly to how spacemacs has the leader key and a number of
mnemonic bindings, it'd be nice to do something similar.

I'd define a standard prefix, possibly a function key, and then spin
off from there. I'd like separate ones for
- things :: various apps and utilities. Elfeed, notmuch, org-agenda,
  notes, etc
- lsp / prog :: a key that gets you access to all bindings specified
  for the major prog mode you're working in.
- errors :: flycheck and or flyspell. Probably a hydra that lets you
  go from error to error (or just suggestions), correct
  them, or view all in a separate window


Let's create a couple prefixes:
#+BEGIN_SRC emacs-lisp
  (defconst my-format-buffer "<f1>")

  (defmacro create-definer (name key)
    "Create a constant and an associated definer.

  Use NAME to generate the name of the constant and definer, and
  use KEY for the definer prefix."
    (let ((constant-name (intern (format "my-%s-prefix" name)))
          (def-name (intern (format "my-%s-def" name))))
      `(progn
         (defconst ,constant-name ,key)
         (general-create-definer ,def-name :prefix ,constant-name))))

  (defmacro create-definers (&rest bindings)
    "Create definers for the given list of arguments.

  BINDINGS is a list of name and keys."
    (let (forms)
      (while bindings
        (let ((key (pop bindings)))
          (when (not bindings)
            (error "Couldn't create definers. The provided bindings are unbalanced"))
          (let ((value (pop bindings)))
            (push `(create-definer ,key ,value) forms))))
      `(progn ,@(nreverse forms))))

  (create-definers
   "link" "C-x l"
   "flycheck" "C-c e"
   "lsp" "<f6>"
   "app" "<f5>"
   "package" "C-x p"
   "file" "C-x f")
#+END_SRC

* OS/system variables

#+BEGIN_SRC emacs-lisp
  (defconst on-macos (eq system-type 'darwin) "t if the current system is a darwin system (running macOS)")
  (defconst on-linux (eq system-type 'gnu/linux) "t if the current system is a linux system")
  (defconst use-exwm (and (display-graphic-p) on-linux) "t if exwm should be activated")
  (defconst native-comp (require 'comp nil t) "non-nil if Emacs uses native compilation")
#+END_SRC

* Emacs

** Visual

These changes relate to how Emacs itself looks, including frames,
windows, and the like.

*** Frames

Get rid of tool bars and menu bars:
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
#+END_SRC

*** Windows

Let's get rid of scroll bars:
#+BEGIN_SRC emacs-lisp
  (set-scroll-bar-mode nil)
#+END_SRC

I don't care much for fringes, so let's decrease the size a bit.

#+BEGIN_SRC emacs-lisp
  (set-fringe-mode 1)
#+END_SRC


*** Theme

To load a theme in Emacs, the default way is to use `M-x
load-theme`. This works well except for the fact that you need to
confirm that you really want to load it unless it's been added to
the 'safe themes' custom list. Also, Emacs doesn't disable the
modifications from a previous theme when you load a new one, so if
the previous theme defines more faces than the new one, some of
these will remain. To get around that we'll disable the old theme
if it is not the same as the new one.

#+BEGIN_SRC emacs-lisp
  (defun heartman/load-theme (theme)
    "Load custom theme named THEME from its file and enable it.

  Calls out to Emacs' own `load-theme' under the hood."
    (interactive
     (list
      (intern
       (completing-read "Load custom theme: "
                        (mapcar #'symbol-name
                                (custom-available-themes))))))

    (let ((old-theme (car custom-enabled-themes)))
      (when (not (eq theme old-theme))
        (message "Disabling theme %s" old-theme theme)
        (disable-theme old-theme))
      (load-theme theme t)
      (message "Loaded theme %s" theme)))
#+END_SRC


**** one-themes
:PROPERTIES:
:REPO:     https://github.com/balajisivaraman/emacs-one-themes
:header-args: :tangle no
:END:

I've been stuck with the Atom One Dark theme since I first saw it
a couple of years ago. This theme is the best Emacs-version I've
seen of it thus far.

However, the theme also affects certain font faces by default,
enabling mixed-pitch-mode for certain headings and changing other
font sizes. While it's not terrible, Emacs does better without
changing these things, so let's disable those changes.

#+BEGIN_SRC emacs-lisp
  (use-package one-themes
    :after org
    :init
    (setq emacs-one-use-variable-pitch nil
          emacs-one-scale-org-headlines nil
          emacs-one-height-minus-1 1.0
          emacs-one-height-plus-1 1.0
          emacs-one-height-plus-2 1.0
          emacs-one-height-plus-3 1.0
          emacs-one-height-plus-4 1.0))

#+END_SRC

**** doom themes
:PROPERTIES:
:REPO:     https://github.com/hlissner/emacs-doom-themes
:END:

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (doom-themes-visual-bell-config)
    (doom-themes-org-config))
#+END_SRC

**** Modus themes

Modus themes are another set of themes that I quite like. These are
high-contrast themes and come bundled with emacs.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (modus-themes-slanted-constructs t)
    (modus-themes-region 'bg-only))
#+END_SRC

**** Loading a theme

To try and stick to loading only one theme, let's do it here.

#+BEGIN_SRC emacs-lisp
  (unless (version<= emacs-version "28")
    (load-theme 'modus-operandi))
#+END_SRC


*** Font

The default font size is a bit small on my monitors, so we'll
increase it sufficiently.
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :height 200)
#+END_SRC

Next, let's set a list of my preferred fonts (in descending order
of preference), and check whether they exist on the system. If
they do, we'll set the first font we find as the default frame
font.

#+BEGIN_SRC emacs-lisp
  (defvar preferred-fonts '("Cascadia Code"
                            "JetBrains Mono"
                            "Victor Mono")
    "The list of preferred fonts in descending order. Emacs will
    use the first font it finds in this list.")

  (require 'cl)

  (let ((font (find-if
               (lambda (font) (member font (font-family-list))) preferred-fonts)))
    (when font
      (set-frame-font font t t)))
#+END_SRC

**** Emoji

Because most fonts don't deal with Emoji, we have to set special
fonts for the emoji range. This snippet from [[http://ergoemacs.org/emacs/emacs_list_and_set_font.html][Ergoemacs' article
and fonts]] allows us to do just that.

When it's active, these emoji should render as expected:

😄 😱 😸 👸 👽 🙋 🥳

Additionally, some emoji use [[https://emojipedia.org/emoji-zwj-sequence/][ZWJ sequences]]. At the moment, I have not
been able to render these correctly in Emacs, but that may have more
to do with the font than with Emacs. The emoji in the table below use
zero-width joiners. When they all display as single emoji, we'll know
be closer to full support.

| Emoji  |
|--------|
| 👨‍👨‍👦 |
| 👨🏾‍🦱 |
| 🙋🏾‍♀️  |


#+BEGIN_SRC emacs-lisp
  ;; set font for emoji
  (set-fontset-font
   t
   '(#x1f300 . #x1fad0)
   (cond
    ((member "Noto Color Emoji" (font-family-list)) "Noto Color Emoji")
    ((member "JoyPixels" (font-family-list)) "JoyPixels")
    ((member "Noto Emoji" (font-family-list)) "Noto Emoji")
    ((member "Segoe UI Emoji" (font-family-list)) "Segoe UI Emoji")
    ((member "Apple Color Emoji" (font-family-list)) "Apple Color Emoji")
    ((member "Symbola" (font-family-list)) "Symbola")))
#+END_SRC

**** Mode line font size

We can make the mode line font be a little smaller than default to
give ourselves a little bit of extra space (based on [[https://emacs.stackexchange.com/a/1062][this answer on stack exchange]]):

#+BEGIN_SRC emacs-lisp
  (defvar heartman/mode-line-font-size .8
    "The size of the mode line font relative to the default.")

  (defun heartman/set-mode-line-font-size ()
    (interactive)
    (let ((faces '(mode-line
                   mode-line-buffer-id
                   mode-line-emphasis
                   mode-line-highlight
                   mode-line-inactive)))
      (mapc
       (lambda (face)
         (set-face-attribute face nil
                             :height heartman/mode-line-font-size))
       faces)))
#+END_SRC


*** Transparency

To set transparency, use ~(set-frame-parameter (selected-frame) 'alpha '(100 100))~

#+BEGIN_SRC emacs-lisp
  (defvar heartman/frame-opacity 93
    "The default frame opacity.")

  (add-to-list 'default-frame-alist `(alpha .  ,heartman/frame-opacity))
#+END_SRC

** Misc

*** ido mode

Inspired by the [[https://www.masteringemacs.org/article/introduction-to-ido-mode][Introduction to ido mode article]] from Mastering
Emacs, let's enable ido mode everywhere and also enable
flex-matching.
#+begin_src emacs-lisp
  (setq ido-enable-flex-matching t)
#+end_src

We can also use ido-mode for find file at point.
#+BEGIN_SRC emacs-lisp
  (setq ido-use-filename-at-point 'guess)
#+END_SRC

When entering a buffer name that doesn't exist when changing
buffers, let's let ido-mode create a new buffer.
#+BEGIN_SRC emacs-lisp
  (setq ido-create-new-buffer 'always)
#+END_SRC

*** Prompts

Taking another cue from Mastering Emacs ([[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in
Emacs]]), let's reduce the amount of prompts we come across in
Emacs:
#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
  (setq confirm-nonexistent-file-or-buffer nil)
#+END_SRC

We can also disable prompts about killing buffers with live
processes attached.
#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-funcions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

*** subword mode

Subword mode lets you navigate and act on parts of words when they
consist of multiple words put together, separated by capital
letters (as is common in programming), such as "GtkWindow" ("Gtk"
and "Window").

#+BEGIN_SRC emacs-lisp
  (dolist (mode '(prog-mode-hook text-mode-hook))
    (add-hook mode (lambda () (subword-mode 1))))
#+END_SRC

*** Hungry-backspace

Let's set up global hungry backspace keybindings too.

#+BEGIN_SRC emacs-lisp
  (general-def
    "C-c <DEL>" 'c-hungry-delete-backwards
    "C-c C-<DEL>" 'c-hungry-delete-backwards
    "C-c <C-delete>" 'c-hungry-delete-forward
    "C-c <deletechar>" 'c-hungry-delete-forward)
#+END_SRC


*** Startup

Let's get rid of splash screens and startup messages that we don't
need (also from [[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in Emacs]]):
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+END_SRC


*** recent files (recentf)                                       :keybinding:

Mickey Petersen suggests using the recent files package in his
[[https://www.masteringemacs.org/article/find-files-faster-recent-files-package][Find Files Faster with the Recent Files Package]], so we'll copy his
suggested configuration here.

#+BEGIN_SRC emacs-lisp
  (require 'recentf)

  (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

  (recentf-mode t)

  (setq recentf-max-saved-items 50)

  (defun ido-recentf-open ()
    "Use `ido-completing-read to \\[find-file] a recent file"
    (interactive)
    (if (find-file (ido-completing-read "Find recent file: " recentf-list))
        (message "Opening file ...")
      (message "Aborting")))
#+END_SRC

*** Quality of life things

Additionally, let's enable a few things that just makes life
better in general:

Electric pair mode is great for automatic insertion of matching
braces. However, it clashes with smartparens, so we'll leave it
out for now.
#+BEGIN_SRC emacs-lisp
  ;; (electric-pair-mode)
#+END_SRC

Further, let's enable line numbers everywhere.
#+BEGIN_SRC emacs-lisp
  (global-display-line-numbers-mode)
#+END_SRC

Make lines wrap visually if they're longer than what can fit in
the window. By default, visual line mode overrides a number of
functions that work on lines, but I find this confusing, so we'll
remove the key overrides it provides.
#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode)
  (general-unbind
    'visual-line-mode-map
    [remap kill-line]
    [remap move-beginning-of-line]
    [remap move-end-of-line])
#+END_SRC

I prefer ending sentences with single spaces (even if I see the
benefits of using two, as recommended by Emacs), so let's also
tell Emacs that it's okay.
#+BEGIN_SRC emacs-lisp
  (setq sentence-end-double-space nil)
#+END_SRC

I also want files to auto-update if they change on disk, but I don't
want Emacs to notify me.
#+begin_src emacs-lisp
  (global-auto-revert-mode)
  (setq auto-revert-verbose nil)
#+end_src

Trailing whitespace is something I prefer to avoid, so let's
delete that on save.
#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

For text modes, let's always use auto-fill mode and abbrev-mode:
#+begin_src emacs-lisp
  (defun my-text-mode-hook ()
    (auto-fill-mode)
    (abbrev-mode))
  (add-hook 'text-mode-hook 'my-text-mode-hook)
#+end_src

**** Removing suspend-frame                                      :keybinding:

To disable suspend-frame (I don't think I've ever meant to
activate it), we'll instead replace it by a message saying it has
been unmapped.
#+BEGIN_SRC emacs-lisp
  (global-set-key [remap suspend-frame]
                  (lambda ()
                    (interactive)
                    (message "This keybinding is disabled (was 'suspend-frame')")))
#+END_SRC

**** Don't pause redisplay on input events

According to [[https://www.masteringemacs.org/article/improving-performance-emacs-display-engine][Improving the performance of Emacs's Display Engine?]]
by Mickey Petersen, Emacs defaults to pausing all display
redrawing on any input. This may have been useful previously, but
is not necessary anymore.
#+BEGIN_SRC emacs-lisp
  (setq redisplay-dont-pause t)
#+END_SRC

**** Silence 'function got redefined' warnings

It seems some packages redefine certain functions defined
elsewhere. This creates noise in the startup messages. Because I
don't mind this at the moment, I'll silence it:
#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

**** Activate winner-mode

#+BEGIN_SRC emacs-lisp
  (winner-mode)
#+END_SRC

**** Backups

Emacs makes backups by default. I don't want this.

I'll also turn off auto-save and similar files.

These settings are based on the ErgoEmacs articles [[http://ergoemacs.org/emacs/emacs_auto_save.html][Emacs: Auto
Save]] and [[http://ergoemacs.org/emacs/emacs_set_backup_into_a_directory.html][Emacs: Turn Off Backup]].
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil
        auto-save-default nil
        create-lockfiles nil)
#+END_SRC

**** TODO Auto-clearing the echo area
:LOGBOOK:
- State "TODO"       from "TODO"       [2020-08-21 Fri 09:41] \\
  Consider whether I actually want this or not.
- State "TODO"       from              [2020-08-17 Mon 19:50]
:END:

Text displayed in the echo area is often helpful, but it stays
around until you do something again. If the output is large
(several lines), then it can often be more of a nuisance.

The variable ~minibuffer-message-clear-timeout~ was introduced in
Emacs 27 ([[https://www.reddit.com/r/emacs/comments/ibi8rj/clear_the_echo_area_after_timeout/g1vtvyq?utm_source=share&utm_medium=web2x][according to this Reddit comment thread]]) and might work
for this, so we'll use that if we can.

#+BEGIN_SRC emacs-lisp
  (if (version< emacs-version "27")
      (run-with-idle-timer 5 t (lambda () (message nil)))
    (setq minibuffer-message-clear-timeout 5))
#+END_SRC

**** Change frame font size

I've got a multi-monitor setup that has a number of different
resolutions and screen sizes. A comfortable font size on one
screen can be too small or too large on another one. As such, I
want a quick and simple way to adjust these on the fly.

#+BEGIN_SRC emacs-lisp
  (defun my-change-frame-font-size ()
    (interactive)
    (set-face-attribute 'default (selected-frame)
                        :height (string-to-number
                                 (read-string "Font height:"))))

  (general-def
    "C-x C-z" 'my-change-frame-font-size)
#+END_SRC

**** Repeat jump to mark

When you want to jump to the previous position in the mark ring,
you can use ~C-u SPC~ . If you want to jump multiple positions,
you must repeat the ~C-u~ press. However, we can make this
unnecessary:

#+BEGIN_SRC emacs-lisp
  (setq set-mark-command-repeat-pop t)

  (defun my-unpop-mark ()
    "Unpop off mark ring. Does nothing if mark ring is empty."
    (interactive)
    (when mark-ring
      (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
      (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
      (when (null (mark t)) (ding))
      (setq mark-ring (nbutlast mark-ring))
      (goto-char (marker-position (car (last mark-ring))))))


  (general-def
    :predicate '(or
                 (eq last-command 'my-unpop-mark)
                 (eq last-command 'pop-to-mark-command))
    "C-M-SPC" 'my-unpop-mark)
#+END_SRC


**** delete-selection-mode

More often than not, when I start typing while I've got an active
region, I want to overwrite what's in the region. The same goes
for when I'm pasting content. By default, Emacs doesn't do this,
but it can easily be enabled:

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode)
#+END_SRC

In case you're using smartparens or other packages that
auto-surround a selection if you input certain delimiters: don't
worry. They'll still work as intended.

**** Switch to previously used window

Emacs doesn't come with an obvious way to cycle between most
recently used windows, but we can create a simple version that
switches to the most previously used window, at least. This is
based on code by github user luciferasm and [[https://github.com/abo-abo/ace-window/issues/125#issuecomment-377354995][was posted in an
issue on ace-window]].

#+BEGIN_SRC emacs-lisp
  (defun my-previous-window ()
    "Switch to the previously active window."
    (interactive)
    (let ((win (get-mru-window t t t)))
      (unless win (error "There is no last window to switch to"))
      (let ((frame (window-frame win)))
        (raise-frame frame)
        (select-frame frame)
        (select-window win))))
#+END_SRC

**** Smarter ~C-a~

When using ~C-a~, I usually want to move to the first
non-whitespace character on the line, even if that is indented.
However, sometimes I want to distinguish between the first
non-whitespace character and column 0. As such, let's write a
function that takes you to indentation first, and to column 0 if
you press it again.

Adapted from [[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][this Emacs Redux blog post]], the option to provide an
argument is mostly for compatibility with the original function
it's made to override.

#+BEGIN_SRC emacs-lisp
  (defun my-move-beginning-of-line (arg)
    "Move point back to indentation or beginning of line.

  Move point to the first non-whitespace character on this line. If
  point is already at this character, move to the beginning of the
  line. Lets you toggle between first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first. If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")

    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((origin (point)))
      (back-to-indentation)
      (when (= origin (point))
        (move-beginning-of-line 1))))

  (general-def
    [remap move-beginning-of-line] 'my-move-beginning-of-line)
#+END_SRC

**** Enable all commands

By default, Emacs disables a number of commands to stop new users
from accidentally triggering them and doing something they don't
expect. To enable all these commands, we do the following:

#+BEGIN_SRC emacs-lisp
  (setq disabled-command-function nil)
#+END_SRC

**** Open line

By default, the ~open-line~ function doesn't indent the part of
the line that gets put onto the next line. I've always found this
to be unintuitive, so let's fix it with this little function.

#+BEGIN_SRC emacs-lisp
  (defun my-open-line (n)
    "Open line below and indent it.

  With numeric prefix arg, open N newlines."
    (interactive "*p")
    (save-excursion
      (newline n)
      (indent-according-to-mode)))

  (general-def
    [remap open-line] 'my-open-line)
#+END_SRC

**** Revert buffer

Let's create a function that'll revert a buffer from file:

#+BEGIN_SRC emacs-lisp
  (defun my-revert-buffer ()
    "Revert the current buffer with no confirmation."
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

  (general-def
    "C-c b r" 'my-revert-buffer)
#+END_SRC

**** RE-builder

As [[https://masteringemacs.org/article/re-builder-interactive-regexp-builder][recommended by Mickey]], let's set the default RE-builder
syntax to be ~string~. Remember that it'll be converted to elisp
if you copy it with ~C-c C-w~.

#+BEGIN_SRC emacs-lisp
  (require 're-builder)
  (setq reb-re-syntax 'string)
#+END_SRC

**** Undo-redo

With Emacs 28.1 comes redo-functionality. Let's bind that to
something useful if it's available.

#+BEGIN_SRC emacs-lisp
  (when (functionp 'undo-redo)
    (general-def
      "M-/" 'undo-redo))
#+END_SRC

**** Unfill region
:LOGBOOK:
- State "TODO"       from              [2021-02-15 Mon 16:03] \\
  Update this to use a prefix argument for acting on the entire buffer?
:END:

I like using auto-fill mode when in Emacs. However, if I want to
copy the content of a buffer into a different application, I'll
often want to get rid of the added newlines. As such, here's a
function to unfill the current region or the current paragraph if
there is no region. With a prefix arg, unfill the whole buffer.

#+BEGIN_SRC emacs-lisp
  (defun unfill-paragraph (&optional region operate-on-whole-buffer)
    "Unfill the current paragraph or the region if it is active.

  With a prefix argument, unfill the whole buffer."
    (interactive (progn (barf-if-buffer-read-only) (list t current-prefix-arg)))
    (let ((fill-column (point-max))
          (emacs-lisp-docstring-fill-column t))
      (if operate-on-whole-buffer
          (fill-region (buffer-end -1) (buffer-end 1))
        (fill-paragraph nil region))))

  (general-def
    "M-Q" 'unfill-paragraph)
#+END_SRC

**** Dired config

We can configure dired to behave a little more intuitively than
it does by default.

Also, as mentioned in [[http://pragmaticemacs.com/emacs/automatically-revert-buffers/][this post on pragmatic emacs]],
~global-auto-revert-mode~ doesn't apply to dired buffers, so we need
to add a separate hook for that.

#+BEGIN_SRC emacs-lisp
  (setq dired-isearch-filenames t
        dired-listing-switches "-lah")

  (add-hook 'dired-mode-hook 'auto-revert-mode)

  (use-package emacs
    :custom
    (dired-auto-revert-buffer t))
#+END_SRC

**** Display battery in mode line

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (battery-mode-line-format "%b%p%% (%05t) "))
  (display-battery-mode)
#+END_SRC

**** Delete current file
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-03-12 Fri 09:12]
- State "TODO"       from              [2021-03-12 Fri 08:59] \\
  With a prefix arg, kill the current buffer too.
:END:

For when you want to delete the current file:

#+BEGIN_SRC emacs-lisp
  (defun heartman/delete-current-file (keep-window)
    "Delete the current file and delete the window.

  When KEEP-WINDOW is non-nil, keep the current window."
    (interactive "P")
    (let ((file (buffer-file-name)))
      (if (and file (f-file-p file))
          (progn
            (when (y-or-n-p "Do you really want to delete this file? ")
              (delete-file file)
              (unless keep-window
                (message "Get here")
                (my-kill-current-buffer t))
              (message "Deleted %s" file)))
        (user-error "This is not a file and cannot be deleted"))))
#+END_SRC

**** Alt completing read

This alternate completing read function is inspired by [[http://www.howardism.org/Technical/Emacs/alt-completing-read.html][this blog
post]] on creating a completing read function that accepts an
association list of items.

#+BEGIN_SRC emacs-lisp
  (defun heartman/completing-read-map (prompt collection &optional predicate require-match initial-input hist def inherit-input-method)
    "Call completing read using PROMPT and COLLECTION (alist or hash table).

  A wrapper around the `completing-read' function that assumes the collection is either an alist or a hash table, and returns the _value_ of the choice instead of the selected choice (the key)."
    (cl-flet ((assoc-list-p (obj) (and (listp obj) (consp (car obj)))))
      (let* ((choice
              (completing-read prompt collection predicate require-match initial-input hist def inherit-input-method))
             (results (cond
                       ((hash-table-p collection) (gethash choice collection))
                       ((assoc-list-p collection) (alist-get choice collection def nil 'equal))
                       (t choice))))
        results)))
#+END_SRC

**** Universal argument remap

I'm experimenting with using ~C-u~ for scrolling up and down (taken from Vim), and as part of that want to be able to use ~M-u~ as a replacement for ~C-u~. The standard binding is pretty useless anyway (and superseded by evil word casing functions), so changing it should be just fine.

#+BEGIN_SRC emacs-lisp
  (general-def
    "M-u" 'universal-argument)
  (general-def
    universal-argument-map
    "M-u" 'universal-argument-more
    "s-u" 'universal-argument-more)
#+END_SRC

*** Remove advice

Sometimes, working with advice can be hard and removing one isn't
always easy. The function below (shamelessly copied from [[https://emacs.stackexchange.com/a/33344][this
stackexchange answer]]) gives an interactive way to remove advice.

#+BEGIN_SRC emacs-lisp
  (defun heartman/advice-list (symbol)
    (let (result)
      (advice-mapc
       (lambda (ad props)
         (push ad result))
       symbol)
      (nreverse result)))

  (defun heartman/kill-advice (symbol advice)
    "Kill ADVICE from SYMBOL."
    (interactive (let* ((sym (intern (completing-read "Function: " obarray #'heartman/advice-list t)))
                        (advice (let ((advices-and-their-name
                                       (mapcar (lambda (ad) (cons (prin1-to-string ad)
                                                                  ad))
                                               (heartman/advice-list sym))))
                                  (cdr (assoc (completing-read "Remove advice: " advices-and-their-name nil t)
                                              advices-and-their-name)))))
                   (list sym advice)))
    (advice-remove symbol advice))
#+END_SRC


*** Scroll a line at a time

When moving off the edge of the screen, Emacs tries to center the
point on the screen instead. This scroll behavior is a bit strange, so
let's instead make it work so that if you move the point off the
screen, Emacs will only scroll as little as it has to.

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (scroll-conservatively 101))
#+END_SRC

*** Don't show line numbers in image modes

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook
    (image-mode . (lambda () (display-line-numbers-mode -1)))
    (image-dired-display-image-mode . (lambda () (display-line-numbers-mode -1))))
#+END_SRC


*** Switch to window

When switching windows, it's sometimes easier to switch by name
than by navigating one window/frame at a time. This function
displays the list of the buffers displayed in the current windows
and allows you to switch to a window based on the buffer it
contains.

#+BEGIN_SRC emacs-lisp
  (defun heartman/select-window (window)
    "Switch to a window containing a buffer by the name of NAME.

  If multiple windows contain buffers with the same name, which one
  is chosen is not guaranteed."
    (interactive
     (list
      (heartman/completing-read-map "Switch to window: "
                                    (mapcar (lambda (w) `(,(buffer-name (window-buffer w)) . ,w))
                                            (window-list-1 nil nil 'visible)))))
    (select-window window))
#+END_SRC

*** show-matching-buffers

I'd like a function to open all buffers that match a certain regex.
This is most relevant when it comes to EXWM buffers, such as Firefox
or Alacritty.

In short, here's what I'd like to happen.
1. The user triggers the function and is prompted by a list of
   open buffers (similar to ~switch-to-buffer~)
2. As they type in, the list filters down, only showing the buffers
   that match the regex
3. When the user confirms their selection, all buffers that are
   currently displayed should be opened in the current frame. The
   first one should replace the buffer in the current window. For
   the remaining buffers: new windows should be created. If
   necessary: balance the windows to create more space.

   Optionally, make this function replace all windows in the
   current frame. That would probably make it easier.

   #+BEGIN_SRC emacs-lisp
     (defun heartman/split-largest-window ()
       "Split the largest window in the current frame.

     Splits the window along it's longest axis (bottom or right)."
       (interactive)
       (cl-flet ((split-window-f (window width height)
                                 (let ((side (if (> height width)
                                                 'below
                                               'right)))
                                   (split-window window nil side t)))

                 (create-window-plist (w) (let* ((height (window-pixel-height w))
                                                 (width (window-pixel-width w))
                                                 (area (* height width)))
                                            `(window ,w height ,height width ,width area ,area))))
         (require 'seq)
         (let* ((windows (mapcar #'create-window-plist (window-list)))
                (largest-window (seq-reduce (lambda (largest next)
                                              (message "largest: %s next %s" largest next)
                                              (if (> (plist-get next 'area) (plist-get largest 'area))
                                                  next
                                                largest)) (cdr windows)
                                                (car windows))))
           (split-window-f
            (plist-get largest-window 'window)
            (plist-get largest-window 'width)
            (plist-get largest-window 'height))
           (balance-windows))))
   #+END_SRC


#+BEGIN_SRC emacs-lisp
  (defun heartman/show-matching-buffers (buffers)
    "Show all buffers matching a given regex."
    (interactive
     (list
      (let* ((buffer-names (mapcar #'buffer-name (buffer-list)))
             (regex
              (completing-read "Buffers matching: " buffer-names))
             (filtered
              (mapcar
               (lambda (name)
                 (get-buffer name))
               (seq-filter
                (lambda (name)
                  (string-match-p regex name)) buffer-names))))
        filtered)))
    (message "The buffers are %s" buffers))
#+END_SRC

*** heartman/split-window-sensibly

#+BEGIN_SRC emacs-lisp
  (defun heartman/split-window-sensibly (&optional window)
    "Split WINDOW in a way suitable for `display-buffer'.
  WINDOW defaults to the currently selected window. If
  `split-width-threshold' specifies an integer, WINDOW is at least
  `split-width-threshold' columns wide and can be split
  horizontally, split WINDOW into two windows side by side and
  return the window on the right. Otherwise, if
  `split-height-threshold' specifies an integer, WINDOW is at least
  `split-height-threshold' lines tall and can be split vertically,
  split WINDOW into two windows one above the other and return the
  lower window. If this can't be done either and WINDOW is the only
  window on its frame, try to split WINDOW vertically disregarding
  any value specified by `split-height-threshold'. If that
  succeeds, return the lower window. Return nil otherwise.
  "
    (interactive)
    (let* ((window (or window (selected-window)))
           (width (window-pixel-width window))
           (height (window-pixel-height window)))
      (or (and
           (and (>= width height) (window-splittable-p window t))
           (with-selected-window window
             (split-window-right)))
          (and
           (and (> height width) (window-splittable-p window))
           (with-selected-window window
             (split-window-below)))
          (and
           ;; If WINDOW is the only usable window on its frame (it is
           ;; the only one or, not being the only one, all the other
           ;; ones are dedicated) and is not the minibuffer window, try
           ;; to split it vertically disregarding the value of
           ;; `split-height-threshold'.
           (let ((frame (window-frame window)))
             (or
              (eq window (frame-root-window frame))
              (catch 'done
                (walk-window-tree (lambda (w)
                                    (unless (or (eq w window)
                                                (window-dedicated-p w))
                                      (throw 'done nil)))
                                  frame nil 'nomini)
                t)))
           (not (window-minibuffer-p window))
           (let ((split-height-threshold 0))
             (when (window-splittable-p window)
               (with-selected-window window
                 (split-window-below))))))))

  (use-package emacs
    :custom
    (split-width-threshold 60)
    (split-height-threshold 20)
    (split-window-preferred-function #'heartman/split-window-sensibly))
#+END_SRC


*** heartman/kill-matching-buffers

The built-in ~kill-matching-buffers~ function doesn't offer you any
preview of what buffers it would kill, so we can make an improved
version that offers you a preview.

Used with ~selectrum~ (or presumably any other framework that offers
you an interactively filtered list of buffers), the ~completing-read~
dialog will list all buffers the function would kill. You can either
pick one buffer or use ~C-j~ (the default key binding) to accept your
current input. The latter will use whatever is in your input to filter
the list of buffers and kill the matching buffers.

#+BEGIN_SRC emacs-lisp
  (defun heartman/kill-matching-buffers (regex buffers)
    "Kill buffers in BUFFERS matching REGEX.

  When called interactively, prompt the user for input and use `buffer-list' as the BUFFERS argument."
    (interactive
     (let* ((buffer-names (mapcar #'buffer-name (buffer-list)))
            (regex
             (completing-read "Kill buffers: " buffer-names)))
       (list regex buffer-names)))
    (mapc #'kill-buffer (seq-filter
                         (lambda (name)
                           (string-match-p regex name)) buffers)))
#+END_SRC



*** Scroll distance
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-12-15 Tue 10:19]
- State "TODO"       from              [2020-12-14 Mon 16:24] \\
  Update this to instead advise the scroll functions by setting the
  number of lines that they should leave to be half the selected
  window's height.

  Advice isn't always recommended, but I think (hope) it should be fine in this
  case, and it would also give me a chance to try and understand how
  advice works.
:END:

By default, emacs scrolls a whole screen at a time. I'd rather it
scrolled half a screen as that makes it easier to keep your
context. As such, let's write a function for that and overwrite
the emacs scroll bindings.

#+BEGIN_SRC emacs-lisp
  (defun half-height (window)
    "Return half the height of WINDOW."
    (max 1 (/  (1- (window-height window)) 2)))

  (defun half-screen (window f &optional lines?)
    "Apply LINES? or half the height of WINDOW to F."
    (let ((lines (or lines? (half-height window))))
      (apply f (list lines))))


  (defun half-screen-other-window (f &optional lines)
    "Apply LINES or half the height of the scrolled window to F."
    (half-screen (other-window-for-scrolling) f lines))

  (defun half-screen-current-window (f &optional lines)
    "Apply LINES or half the height of the scrolled window to F."
    (half-screen (selected-window) f lines))

  (dolist (f '(scroll-down-command scroll-up-command))
    (advice-add f :around #'half-screen-current-window))

  (dolist (f '(scroll-other-window scroll-other-window-down))
    (advice-add f :around #'half-screen-other-window))
#+END_SRC


*** Package management

The below recipe repo update function is copied from [[https://github.com/raxod502/straight.el/pull/576][this PR to
straight.el]]. It should make it into master eventually.

#+BEGIN_SRC emacs-lisp

  (defun my-straight-pull-recipe-repositories (&optional sources)
    "Update recipe repository SOURCES.
  When called with `\\[universal-argument]', prompt for SOURCES.
  If SOURCES is nil, update sources in `straight-recipe-repositories'."
    (interactive (list (if (equal current-prefix-arg '(4))
                           (completing-read-multiple
                            "Recipe Repositories (empty to select all): "
                            straight-recipe-repositories nil 'require-match)
                         straight-recipe-repositories)))
    (dolist (source (delete-dups
                     (mapcar (lambda (src) (if (stringp src) (intern src) src))
                             (or sources straight-recipe-repositories))))
      (unless (member source straight-recipe-repositories)
        (user-error
         (concat "Unregistered recipe repository: \"%S\". "
                 "Register recipe source with straight-use-recipes")
         source))
      (straight-pull-package-and-deps (symbol-name source) 'upstream)))


  (my-package-def
    "U" 'straight-pull-all
    "u" 'my-straight-pull-recipe-repositories
    "r" 'my-straight-pull-recipe-repositories
    "i" 'straight-use-package)
#+END_SRC


*** column-number-mode

To see what the current column number is, activate
column-number-mode:
#+BEGIN_SRC emacs-lisp
  (column-number-mode)
#+END_SRC


*** Copy current file path

#+BEGIN_SRC emacs-lisp
  (defun xah-copy-file-path (&optional @dir-path-only-p)
    "Copy the current buffer's file path or dired path to `kill-ring'.

    Result is full path.
    If `universal-argument' is called first, copy only the dir path.

    If in dired, copy the file/dir cursor is on, or marked files.

    If a buffer is not file and not dired, copy value of
    `default-directory' (which is usually the “current” dir when
    that buffer was created)

    URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
    Version 2017-09-01"
    (interactive "P")
    (let (($fpath
           (if (string-equal major-mode 'dired-mode)
               (progn
                 (let (($result (mapconcat 'identity (dired-get-marked-files) "\n")))
                   (if (equal (length $result) 0)
                       (progn default-directory )
                     (progn $result))))
             (if (buffer-file-name)
                 (buffer-file-name)
               (expand-file-name default-directory)))))
      (kill-new
       (if @dir-path-only-p
           (progn
             (message "Directory path copied: 「%s」" (file-name-directory $fpath))
             (file-name-directory $fpath))
         (progn
           (message "File path copied: 「%s」" $fpath)
           $fpath )))))

  (my-file-def
    "c" 'xah-copy-file-path)
#+END_SRC


*** Join lines

In Vim, you can easily join the next line onto the current by
pressing ~J~. I often want something like this in Emacs, so let's
create a similar version:
#+BEGIN_SRC emacs-lisp
  (defun my-join-next-line ()
    "Join the next line onto the current line."
    (interactive)
    (save-excursion
      (next-logical-line)
      (join-line)))

  (defun my-join-line ()
    "Join the previous line, but keep point's position."
    (interactive)
    (save-excursion
      (join-line)))

  (general-def
    "C-S-j" 'my-join-next-line
    "C-S-k" 'my-join-line)
#+END_SRC


*** browser / opening urls                                               :os:

Without setting a browser, it seems that links don't open (at
least not on Linux). Let's set it to Firefox:
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function
        (if on-macos
            'browse-url-default-macosx-browser
          'browse-url-firefox))
#+END_SRC

*** Garbage collection

Inspired by the [[https://github.com/lewang/flx][flx's readme]], we can increase the GC threshold
significantly from the default. In addition to when using flx,
this might also come in handy in other situations.
#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 20000000)
#+END_SRC

*** subprocess throughput

This section increases the throughput available to subprocesses.
This value was hardcoded before Emacs 27, so we first want to
check whether the variable is bound or not. If it is, increase it.

#+BEGIN_SRC emacs-lisp
  (when (boundp 'read-process-output-max)
    (setq read-process-output-max (* 1024 1024 3)))
#+END_SRC

*** Window functions
:LOGBOOK:
- State "TODO"       from              [2020-08-13 Thu 20:16]
:END:

One of the things I really like about Spacemacs is that the key
for maximizing a window if there are other windows in the frame is
also the key for bringing the other windows back if the current
window is the only one.

Turns out that function is based on [[https://gist.github.com/mads-hartmann/3402786][this gist]], which we can
casually copy here.
#+BEGIN_SRC emacs-lisp
  (defun my-maximize-or-undo-window ()
    "Maximize the current window or revert to a previous window setting.

  If there are multiple windows in the frame, maximize the current
  one.

  If there is only one window in the current frame, revert to the
  previous multi-window configuration.

  When reverting, leave the current window's buffer as is."
    (interactive)
    (save-excursion
      (if (and (= 1 (count-windows))
               (assoc ?_ register-alist))
          (let ((window-buffer (current-buffer)))
            (jump-to-register ?_)
            (switch-to-buffer window-buffer nil t))
        (progn
          (window-configuration-to-register ?_)
          (delete-other-windows)))))
#+END_SRC

Further, I'd love to be able to maximize windows vertically or
horizontally. Again, this is functionality Spacemacs has, so let's
go from there.

And if we can maximize horizontally and vertically, why not make
it more fine-grained? What if you only want to expand in one
direction?

And finally: what if you just want to 'eat' the next window in a
given direction? Yeah, we can do all of them.

First, let's define functionality to delete windows in a direction
until there's nothing left to delete.
#+BEGIN_SRC emacs-lisp
  (defun delete-until-end (move)
    (while (condition-case nil (funcall move) (error nil))
      (delete-window)))
#+END_SRC

Now, let's implement this for the four directions. NOTE: I'm sure
this can be done in a fancier, metaprogramming-like way. Please,
/do/ @ me!
#+BEGIN_SRC emacs-lisp
  (defun delete-windows-to-the-left ()
    "Delete all windows to the left of the current one"
    (interactive)
    (delete-until-end 'windmove-left))

  (defun delete-windows-to-the-right ()
    "Delete all windows to the right of the current one"
    (interactive)
    (delete-until-end 'windmove-right))

  (defun delete-windows-above ()
    "Delete all windows above the current one"
    (interactive)
    (delete-until-end 'windmove-up))

  (defun delete-windows-below ()
    "Delete all windows below the current one"
    (interactive)
    (delete-until-end 'windmove-down))
#+END_SRC

Now horizontal and vertical are just extensions of what we've got
above:
#+BEGIN_SRC emacs-lisp
  (defun maximize-window-horizontally ()
    (interactive)
    (save-excursion
      (delete-windows-to-the-left)
      (delete-windows-to-the-right)))

  (defun maximize-window-vertically ()
    (interactive)
    (save-excursion
      (delete-windows-above)
      (delete-windows-below)))
#+END_SRC

Swell! That only leaves eating the next window in one direction.
Again, let's define the base function and then one-line
implementations! Or ... before we got too ahead of ourselves,
let's think about how Emacs works with windows.

If you delete a window, another window will take its place so that
we don't get an empty hole in the frame. However, from what I've
gathered, Emacs follows a few simple rules when deciding which
window will grow to take the newly opened space.

- If there is only one window left, grow this one.
- If there are multiple candidates that could fill the void,
  always pick the candidate to the left or above. In other words:
  windows only grow downwards and to the right.

  #+BEGIN_EXAMPLE
    +--------+
    |  |  |  |
    |  |  |x | <- if we delete the window to the left
    |  |  |  |
    +--------+



    +--------+
    |     |  |
    |     |x | <- this is what we'll get
    |     |  |
    +--------+
  #+END_EXAMPLE

  This last point is quite important. It means that if you want to
  grow a window up or to the left: that's not as easy as you might
  have thought. Further: you can't just swap the buffers and delete
  to the right either, because that wouldn't always work.

  As an example, say you have this setup, where ~x~ is your current window.
  #+BEGIN_EXAMPLE
    +----+----+
    |    |    |
    |    |----|
    |    | x  |
    +----+----+
  #+END_EXAMPLE

  If you want to simply expand one window to the left (into the tall
  window), you'd expect to end up with a horizontally split screen.
  But if we swap the two windows first and expand to the right,
  we'll get a horizontal split instead.
  #+BEGIN_EXAMPLE
    +---------+                                        +---------+
    |         |                                        |    |    |
    |---------| <- we want this, but we'll get this -> |    |    |
    |         |                                        |    |    |
    +---------+                                        +---------+
  #+END_EXAMPLE

  However, it is doable. Here's how (using left as the direction,
  but it works for up too).

  1. First move to the left window.
  2. Before deleting it, get the width (height) of the window using
     ~window-total-width~ (~window-total-height~).
  3. After the window has been deleted, try and move to the left
     again. If you can't, that means there was no third window to
     the left that could have taken your place. If you /can/,
     however: Move into that window and ~shrink-window-horizontally~
     (~shrink-window~) by the width (height) of the window that we
     deleted.
  4. Then, move back into the window we started from.

     #+BEGIN_SRC emacs-lisp
       (defun delete-window-direction (move)
         "Delete a window in the specified direction and return to where
         you were. If there are no more windows in said direction, don't
         do anything."
         (save-excursion
           (if (condition-case nil (funcall move) (error nil))
               (delete-window)
             (message "No window to delete in that direction."))))

       (defun delete-window-left-or-up (move move-back get-dimenson shrink)
         (save-excursion
           (if (condition-case nil (funcall move) (error nil))
               (let ((delta (funcall get-dimenson)))
                 (delete-window)
                 (when (condition-case nil (funcall move) (error nil))
                   (funcall shrink delta)
                   (funcall move-back)))
             (message "No window to delete in that direction."))))

       (defun delete-window-up ()
         (interactive)
         (delete-window-left-or-up
          'windmove-up
          'windmove-down
          'window-total-height
          'shrink-window))

       (defun delete-window-left ()
         (interactive)
         (delete-window-left-or-up
          'windmove-left
          'windmove-right
          'window-total-width
          'shrink-window-horizontally))

       (defun delete-window-right ()
         (interactive)
         (delete-window-direction 'windmove-right))

       (defun delete-window-down ()
         (interactive)
         (delete-window-direction 'windmove-down))
     #+END_SRC



**** Splitting

When splitting a window, I generally always want to focus in the
new window, so let's define some functions for this and bind
them.
#+BEGIN_SRC emacs-lisp
  (defun split-window-right-and-focus ()
    (interactive)
    (split-window-right)
    (windmove-right))

  (defun split-window-below-and-focus ()
    (interactive)
    (split-window-below)
    (windmove-down))

  (global-set-key (kbd "C-x |") 'split-window-right-and-focus)
  (global-set-key (kbd "C-x -") 'split-window-below-and-focus)
  (global-set-key (kbd "C-x _") 'split-window-below-and-focus)
#+END_SRC

*** Buffer functions

#+BEGIN_SRC emacs-lisp
  (defun my-kill-current-buffer (delete-window?)
    "Kill the currently active buffer.

  With a prefix argument, also delete the current window."

    (interactive "P")
    (kill-buffer)
    (when delete-window?
      (delete-window)))
#+END_SRC


*** Rename current file

Based on [[https://stackoverflow.com/a/25212377][this Stack Overflow answer]].
#+BEGIN_SRC emacs-lisp
  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let* ((name (buffer-name))
           (filename (buffer-file-name))
           (basename (file-name-nondirectory filename)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " (file-name-directory filename) basename nil basename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))

  (general-def
    "C-x C-j" 'rename-current-buffer-file)
#+END_SRC

*** Clear default scratch buffer message

To have the scratch buffer be empty by default, we can set the
~initial-scratch-message~ variable:

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

*** Project management

#+BEGIN_SRC emacs-lisp
  (defun my-project-paths ()
    "Get the currently existing top-level project paths"
    (seq-filter 'file-directory-p '("~/projects"
                                    "~/projects/work"
                                    "~/projects/personal")))
#+END_SRC

*** Tabs
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-06-15 Tue 17:30]
- State "TODO"       from              [2021-06-15 Tue 10:03] \\
  Fix tab movement between frames.
- State "DONE"       from "TODO"       [2021-04-26 Mon 15:47]
- State "TODO"       from              [2021-04-26 Mon 15:34] \\
  Turns out I was wrong regarding the extra tab named the same as the
  current buffer. What happens is: the tab bar fetching functions looks
  for tabs that have explicit names. If it doesn't have an explicit
  name, it uses the name of the currently active buffer. That's what's
  causing problems.

  Find a way around this. It might involve taking the name of the first
  buffer in the current tab, for instance.
:END:

Emacs tabs can be used for window management (similarly to eyebrowse).
It's nice, but it's missing the ability to switch to any tab on any
frame, so this function sorts that out:

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :custom
    (tab-bar-close-button-show nil)
    (tab-bar-new-button-show nil)
    (tab-bar-show 1)
    (tab-bar-tab-name-function 'tab-bar-tab-name-truncated)
    (tab-bar-tab-name-truncated-max 25)
    :general
    ("C-x t c" 'tab-bar-duplicate-tab
     "C-x t n" 'tab-bar-new-tab)
    :config
    (defun heartman/get-all-other-tabs-any-frame ()
      "Get all tabs on all frames except for the current one.

  Additionally, add a `frame' entry to each tab."
      (let* ((current-frame (selected-frame))
             (other-frames
              (seq-remove (lambda (frame) (eq current-frame frame))
                          (frame-list)))
             (other-tabs-current-frame
              (seq-map (lambda (tab) (cons `(frame . ,current-frame) tab))
                       (seq-remove (lambda (tab) (eq (car tab) 'current-tab))
                                   (funcall tab-bar-tabs-function))))
             (other-tabs-other-frames
              (seq-mapcat (lambda (frame)
                            (seq-map (lambda (tab) (cons `(frame . ,frame) tab))
                                     (seq-map (lambda (tab)
                                                (if (and
                                                     (eq (car tab) 'current-tab)
                                                     (not (alist-get 'explicit-name tab)))
                                                    (cons `(name . ,(alist-get 'name (frame-parameters frame))) tab)
                                                  tab))
                                              (tab-bar-tabs frame))))
                          other-frames))
             (all-other-tabs (seq-concatenate 'list other-tabs-current-frame other-tabs-other-frames)))
        all-other-tabs))

    (defun heartman/switch-to-tab-any-frame (tab)
      "Switch to a different tab on any frame. `tab' is the desired
  tab, including its frame as an alist entry."
      (interactive
       (let* ((tab-bar-show nil)
              (tabs (seq-sort-by
                     (lambda (tab) (or (alist-get 'time tab) 0))
                     #'>
                     (heartman/get-all-other-tabs-any-frame)))
              (tabs-map (seq-map (lambda (tab) `(,(alist-get 'name tab) . ,tab)) tabs))
              (default-choice (alist-get 'name (car tabs-map))))

         (cl-assert (> (length tabs) 0) nil "No tabs to switch to.")
         (list
          (heartman/completing-read-map "Switch to tab: " tabs-map))))
      (let-alist tab
        (select-frame .frame)
        (tab-bar-switch-to-tab .name)))

    (defun heartman/show-tab-other-frame (tab)
      "Show the tab `TAB' on the other frame without changing focus."
      (interactive
       (let* ((other-frames
               (seq-remove (lambda (frame)
                             (eq (selected-frame) frame)) (frame-list)))
              (tabs (seq-mapcat (lambda (frame)
                                  (seq-map (lambda (tab) (cons `(frame . ,frame) tab))
                                           (seq-remove
                                            (lambda (tab) (eq (car tab) 'current-tab)) (tab-bar-tabs frame)))) other-frames))
              (tabs-map (seq-map (lambda (tab) `(,(alist-get 'name tab) . ,tab))
                                 tabs)))
         (cl-assert (> (length tabs) 0) nil "No tabs to show on other frames.")
         (list (heartman/completing-read-map "Show tab: " tabs-map))))
      (let-alist tab
        (let ((original-frame (selected-frame)))
          (save-mark-and-excursion
            (select-frame .frame)
            (tab-bar-switch-to-tab .name)
            (select-frame original-frame)))))

    (defun heartman/tab-other-frame (keep-focus)
      "Switch to a different tab or display a non-current tab on another frame.

  If KEEP-FOCUS is non-nil, prompt for a tab to display on another
  frame. Otherwise, switch to any non-current tab."
      (interactive "P")
      (let ((f (if keep-focus
                   #'heartman/show-tab-other-frame
                 #'heartman/switch-to-tab-any-frame)))
        (call-interactively f)))

    (defun heartman/get-nth-frame (n &optional frame)
      "Get the frame N steps from the current frame."
      (let ((steps (mod n (length (frame-list))))
            (source-frame (or frame (selected-frame))))
        (cl-labels ((go (current-frame num-steps)
                        (if (= 0 num-steps)
                            current-frame
                          (go (next-frame current-frame) (1- num-steps)))))
          (go source-frame steps))))

    (defvar heartman/new-tab-default-buffer
      "*scratch*"
      "The name of the buffer to use when creating a new tab as a
  fallback.

  This can happen in `heartman/send-tab-to-frame' if the tab you
  want to move is the only tab in its frame.")

    (defun heartman/send-tab-to-frame (arg)
      "Send the current frame the ARGth next frame.

  When sending the frame, remove the frame from the source frame."
      (let* ((target-frame (heartman/get-nth-frame (prefix-numeric-value arg)))
             (target-index (1+ (length (funcall tab-bar-tabs-function target-frame))))
             (current-tab-name (alist-get 'name (tab-bar--current-tab))))

        ;; check whether this tab is the only one in the frame. If so,
        ;; create a new tab with only a scratch buffer and then move the
        ;; original tab to its target.
        (when (= 1 (length (funcall tab-bar-tabs-function)))
          (tab-bar-new-tab)
          (switch-to-buffer heartman/new-tab-default-buffer)
          (tab-bar-switch-to-recent-tab))

        (tab-bar-move-tab-to-frame nil nil nil target-frame target-index)

        ;; after moving the tab, focus the new tab in the target frame
        (select-frame target-frame)
        (tab-bar-select-tab-by-name current-tab-name)

        ;; move tab all the way to the right (this should be taken care
        ;; of above, but there seems to be an error(?) in tab-bar.el
        ;; that prohibits this.):
        ;; (to-index (max 0 (min (1- (or to-index 1)) (1- (length to-tabs)))))
        ;; where the last expression means you can't move a new tab all the way to the right.
        (tab-bar-move-tab-to target-index)

        ;; also make sure to display tabs in the new frame! If I move a
        ;; tab to a frame with only one tab (I hide the tab bar when
        ;; there is a single tab), then the tab bar remains hidden.
        (tab-bar--update-tab-bar-lines (list target-frame))))

    (defun heartman/send-tab-to-next-frame ()
      (interactive)
      (heartman/send-tab-to-frame -1))

    (defun heartman/send-tab-to-previous-frame ()
      (interactive)
      (heartman/send-tab-to-frame 1)))
#+END_SRC


*** Current line empty

Is the current line empty?

#+BEGIN_SRC emacs-lisp
  (defun heartman/current-line-empty-p ()
    "Check whether the current line is empty."
    (save-excursion
      (beginning-of-line)
      (looking-at-p "[[:space:]]*$")))


#+END_SRC

** Custom file

To avoid getting customizations stuck into my init.el, I want to
use a separate customization file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC

** Calendar

The emacs calendar uses Sunday as the first day of the week by
default, but I prefer weeks starting on Mondays.
#+BEGIN_SRC emacs-lisp
  (setq calendar-week-start-day 1)
#+END_SRC

* Ivy                                                            :keybinding:

Following the [[https://oremacs.com/swiper/][Ivy Documentation]], let's install Ivy (and Counsel and
Swiper) using counsel. We'll also add Ivy's ~swiper-isearch~ and
~counsel-yank-pop~.

For searches, I also prefer using a fuzzier regex pattern than the
default, so this is set up by assigning ~ivy--regex-fuzzy~.

By default, ~ivy-initial-inputs-alist~ instructs most ivy-functions
to put a ~^~ at the start of the search. While this can be useful
sometimes, I prefer to insert one myself when I need it.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :demand t
    :disabled
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t
          ivy-count-format "(%d/%d)"
          ivy-re-builders-alist '((swiper-isearch . ivy--regex-plus)
                                  (ivy-switch-buffer . ivy--regex-plus)
                                  (t . ivy--regex-fuzzy))
          ivy-wrap t
          ivy-initial-inputs-alist nil)
    :general
    ("C-S-s" 'swiper-isearch
     "C-M-y" 'counsel-yank-pop
     [remap execute-extended-command] 'counsel-M-x
     [remap describe-variable] 'counsel-describe-variable
     [remap describe-function] 'counsel-describe-function))
#+END_SRC

** ivy-rich

Ivy-rich is a package that extends Ivy by formatting the output and
adding more information.

#+BEGIN_SRC emacs-lisp
  (use-package ivy-rich
    :init
    :disabled
    (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
    :config (ivy-rich-mode 1))
#+END_SRC

** TODO ivy-posframe
:LOGBOOK:
- State "TODO"       from              [2020-12-10 Thu 11:39] \\
  This might need some more tweaking.
:END:

Ivy-posframe is a package that allows you to change where ivy
dialogs show up. This setup is based on [[https://www.reddit.com/r/emacs/comments/ehjcu2/screenshot_polishing_my_emacs_who_said_an_old/fcmbozm?utm_source=share&utm_medium=web2x&context=3][this Reddit thread config]].

#+BEGIN_SRC emacs-lisp
  (use-package ivy-posframe
    :when (not on-macos)
    :after ivy-rich
    :disabled
    :preface
    (defun ivy-rich-switch-buffer-icon (candidate)
      (with-current-buffer
          (get-buffer candidate)
        (all-the-icons-icon-for-mode major-mode)))
    :init
    (setq ivy-rich-display-transformers-list ; max column width sum = (ivy-posframe-width - 1)
          '(ivy-switch-buffer
            (:columns
             ((ivy-rich-switch-buffer-icon (:width 2))
              (ivy-rich-candidate (:width 35))
              (ivy-rich-switch-buffer-project (:width 15 :face success))
              (ivy-rich-switch-buffer-major-mode (:width 13 :face warning)))
             :predicate
             #'(lambda (cand) (get-buffer cand)))
            counsel-M-x
            (:columns
             ((counsel-M-x-transformer (:width 35))
              (ivy-rich-counsel-function-docstring (:width 34 :face font-lock-doc-face))))
            counsel-describe-function
            (:columns
             ((counsel-describe-function-transformer (:width 35))
              (ivy-rich-counsel-function-docstring (:width 34 :face font-lock-doc-face))))
            counsel-describe-variable
            (:columns
             ((counsel-describe-variable-transformer (:width 35))
              (ivy-rich-counsel-variable-docstring (:width 34 :face font-lock-doc-face))))
            package-install
            (:columns
             ((ivy-rich-candidate (:width 25))
              (ivy-rich-package-version (:width 12 :face font-lock-comment-face))
              (ivy-rich-package-archive-summary (:width 7 :face font-lock-builtin-face))
              (ivy-rich-package-install-summary (:width 23 :face font-lock-doc-face))))))

    :config
    (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-top-center)))

    (defun my-ivy-posframe-get-size ()
      "Set the ivy-posframe size according to the current frame."
      (let* ((height (or ivy-posframe-height (or ivy-height 10)))
             (min-height (min height (+ 1 (length ivy--old-cands))))
             (width (min (or ivy-posframe-width 200) (round (* .75 (frame-width))))))
        (list :height height :width width :min-height min-height :min-width width)))

    (setq ivy-posframe-size-function 'my-ivy-posframe-get-size)


    (ivy-posframe-mode 1))
#+END_SRC

* Flycheck
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-07-01 Thu 09:10]
- State "TODO"       from              [2021-07-01 Thu 08:56] \\
  Activate flycheck in text-mode and prog-mode buffers; not globally.
:END:

Let's activate flycheck mode pretty much everywhere. Also, let's
change the prefix to something that's easier to remember (type) than
~C-c !~.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :hook
    ((prog-mode text-mode) . flycheck-mode)
    :config
    (define-key flycheck-mode-map flycheck-keymap-prefix nil)
    (setq flycheck-keymap-prefix (kbd my-flycheck-prefix))
    (define-key flycheck-mode-map flycheck-keymap-prefix
      flycheck-command-map))
#+END_SRC

* TODO Company                                                   :keybinding:
:PROPERTIES:
:REPO:     https://github.com/company-mode/company-mode
:END:

TODO: We need to set this up properly. In addition to wanting to use
tab-n-go, I also want to be able to use TAB to expand completions
with function arguments (like Rust Analyzer).

In addition to the basic company-mode configuration, I also use
[[https://github.com/company-mode/company-mode/blob/master/company-tng.el][company-tng]] to get YCMD-like behavior. This requires a little extra
bit of configuration to get set up.

#+BEGIN_SRC emacs-lisp
  (defun my-configure-tng ()
    "Taken and adapted from company-tng.el."
    (setq company-require-match nil)
    (setq company-frontends '(company-tng-frontend
                              company-pseudo-tooltip-frontend
                              company-echo-metadata-frontend))
    ;; (setq company-clang-insert-arguments nil
    ;;       company-semantic-insert-arguments nil
    ;;       company-rtags-insert-arguments nil
    ;;       lsp-enable-snippet nil)
    ;; (advice-add #'eglot--snippet-expansion-fn :override #'ignore)
    (let ((keymap company-active-map))
      (define-key keymap [return] nil)
      (define-key keymap (kbd "RET") nil)))

  (defun my-company-complete-selection-or-first ()
    "Complete the selection if there is one. Otherwise, complete the first item."
    (interactive)
    (when (not company-selection)
      (company-select-first))
    (company-complete-selection))

  (use-package company
    :general
    (company-active-map
     "C-<f5>" 'my-company-complete-selection-or-first)
    (general-unbind
      company-active-map
      [tab]
      "TAB")
    (company-mode-map
     "C-<f5>" 'company-complete)
    :hook
    (company-mode . company-tng-mode)
    (company-mode . my-configure-tng)
    :init
    (setq company-tng-auto-configure nil)
    (global-company-mode)
    :config
    (setq company-idle-delay 0.2
          company-selection-wrap-around t
          company-show-numbers t
          company-format-margin-function #'company-vscode-dark-icons-margin))
#+END_SRC

To make completions a bit smoother, I use [[https://github.com/PythonNut/company-flx][company-flx]] to allow for
fuzzy matching when company uses the company-capf backend. I'll also
add ~fuzzy~ to the list of completion styles.

#+BEGIN_SRC emacs-lisp
  (use-package company-flx
    :after company
    :config
    (company-flx-mode 1)
    (add-to-list 'completion-styles 'fuzzy))
#+END_SRC

** Company-box
:PROPERTIES:
:REPO:     https://github.com/sebastiencs/company-box
:END:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package company-box
    :hook
    (company-mode . company-box-mode))
#+END_SRC

** Company-posframe
:PROPERTIES:
:REPO:     https://github.com/tumashu/company-posframe
:END:

When using varying font sizes within a buffer, this can make the
company completion dropdown misaligned (with itself, even). Using
the [[https://github.com/tumashu/company-posframe][company-posframe package]] appears to fix this by putting
completions in a separate frame.

This should not be used with ~company-box~ as they both modify
company's options.

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package company-posframe
    :after company
    :config (company-posframe-mode 1))
#+END_SRC

** Company-emoji
:PROPERTIES:
:REPO:     https://github.com/dunn/company-emoji
:END:

#+BEGIN_SRC emacs-lisp
  (use-package company-emoji
    :init
    (add-to-list 'company-backends 'company-emoji))
#+END_SRC

* Magit                                                          :keybinding:

Because it's simply one of the best git experiences out there, of
course I want to enable and use Magit:
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :demand t
    :init
    (setq magit-repository-directories (seq-map (lambda (path) `(,path . 2)) (my-project-paths)))
    :config
    (defun magit-status-dotfiles ()
      "Switch to status buffer for dotfiles."
      (interactive)
      (magit-status "~/dotfiles"))
    :bind (("C-x g" . magit-status)
           ("C-x M-g" . magit-dispatch)))
#+END_SRC

Additionally, to smooth out the workflow with GitHub and GitLab,
let's also use Forge.

#+BEGIN_SRC emacs-lisp
  (use-package forge
    :after magit
    :when (require 'emacsql nil t)
    :hook
    (forge-post-mode . (lambda () (auto-fill-mode -1)))
    :bind (:map magit-mode-map
                ("C-c M-w" . forge-copy-url-at-point-as-kill)))
#+END_SRC

* Git-modes
:PROPERTIES:
:REPO:     https://github.com/magit/git-modes
:END:

In addition to just Magit, Magit also has modes for git config,
ignore, and attributes files.

#+BEGIN_SRC emacs-lisp
  (use-package gitattributes-mode)

  (use-package gitconfig-mode)

  (use-package gitignore-mode
    :mode "\\.dockerignore\\'")
#+END_SRC

* Git-timemachine
:PROPERTIES:
:REPO:     https://github.com/emacsmirror/git-timemachine
:END:

Git-timemachine offers a way to browse all revisions of a file.

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine)
#+END_SRC

* github-review
:PROPERTIES:
:REPO:     https://github.com/charignon/github-review
:END:

#+BEGIN_SRC emacs-lisp
  (use-package github-review)
#+END_SRC


* Rainbow delimiters

Rainbow delimiters make it much easier to read a lot of code, so
let's set them up.
#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

* which-key                                                      :keybinding:
:PROPERTIES:
:REPO:     https://github.com/justbur/emacs-which-key/
:END:

which-key shows you a pop-up when you're in the middle of typing key
combinations. If you forget what the exact combination is, this can
be a useful guide.

Because I generally don't want which-key to pop up and disturb the
current frame, I'd like it only to trigger manually. The recommended
way of doing this is by increasing the initial idle delay.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode)
    (setq which-key-show-early-on-C-h t)
    (setq which-key-idle-delay 10000)
    (setq which-key-idle-secondary-delay 0.05))
#+END_SRC

* LSP mode                                                       :keybinding:
:PROPERTIES:
:REPO:     https://github.com/emacs-lsp/lsp-mode
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-11 Tue 20:06]
:END:

For performance tips see [[https://emacs-lsp.github.io/lsp-mode/page/performance/][the performance page for more details]].

This setup is nearly identical to the recommended approach in their
[[https://emacs-lsp.github.io/lsp-mode/page/installation/][installation instructions]], with some minor tweaks.

#+BEGIN_SRC emacs-lisp
  (setq lsp-keymap-prefix my-lsp-prefix)

  (use-package lsp-mode
    :hook
    ((lsp-mode . lsp-enable-which-key-integration))
    :general
    (lsp-mode-map
     :start-maps t
     my-format-buffer 'lsp-format-buffer)
    (my-lsp-def
      :start-maps t
      my-lsp-prefix 'lsp)
    :commands lsp)
  (use-package lsp-ui :commands lsp-ui-mode
    :general
    (:keymaps 'lsp-ui-mode-map
              [remap xref-find-definitions]#'lsp-ui-peek-find-definitions
              [remap xref-find-references]#'lsp-ui-peek-find-references)
    :config
    (when on-macos
      (setq lsp-ui-doc-use-childframe nil))
    (setq lsp-ui-doc-position 'bottom)
    )

  (use-package lsp-ivy :commands lsp-ivy-workspace-symbol
    :general
    :disabled
    (my-lsp-def
      :keymaps 'lsp-mode-map
      "w s" 'lsp-ivy-workspace-symbol))

  (use-package lsp-treemacs :commands lsp-treemacs-error-list)

  (use-package dap-mode)
#+END_SRC

* Rust mode
:PROPERTIES:
:REPO:     https://github.com/rust-lang/rust-mode
:END:

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :mode "\\.rs\\'"
    :after lsp-mode
    :hook
    (rust-mode . lsp)
    :config
    (setq rust-format-on-save t
          lsp-rust-server 'rust-analyzer)
    :general
    (rust-mode-map
     "C-c C-c" 'rust-compile
     "C-c C-t" 'rust-test
     "C-c C-r" 'rust-run))
#+END_SRC

We can also use [[https://github.com/flycheck/flycheck-rust][flycheck-rust]] to improve flycheck cargo handling.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-rust
    :after rust-mode
    :hook
    (flycheck-mode . flycheck-rust-setup))
#+END_SRC

* Direnv mode
:PROPERTIES:
:REPO:     https://github.com/wbolster/emacs-direnv
:END:

[[https://direnv.net/][direnv]] is a great way to load directory-specific environments into
your shell. direnv-mode does the same thing in Emacs. It works using
Nix shells.
#+BEGIN_SRC emacs-lisp
  (use-package direnv
    :demand t
    :config
    (setq direnv-always-show-summary nil)
    (direnv-mode)
    :general
    (my-app-def
      :infix "d"
      "a" 'direnv-allow
      "u" 'direnv-update-environment))
#+END_SRC

* Nix mode                                                       :keybinding:
:PROPERTIES:
:REPO:     https://github.com/NixOS/nix-mode/
:END:

Using NixOS as my main OS and Nix shells for dev environments on
other platforms, it's quite important to get this mode set up.

Of note: nix-mode seems to have a dependency on json-mode, so make
sure to only initialize after said mode.
#+begin_src emacs-lisp
  (use-package nix-mode
    :after json-mode
    :mode "\\.nix\\'"
    :general
    (general-def
      :keymaps 'nix-mode-map
      my-format-buffer 'nix-format-buffer))
#+end_src

* TODO JSON mode
:PROPERTIES:
:REPO:     https://github.com/joshwnj/json-mode
:END:
:LOGBOOK:
- State "TODO"       from              [2020-09-10 Thu 15:30] \\
  Todo: set up auto-formatting before save and bound to my-format-buffer
  key. Should first try to use prettier, and if prettier isn't
  available, should use the built-in json-format-buffer.
:END:

For JSON support and, more specifically, for Nix mode, which seems
to require this.

#+begin_src emacs-lisp
  (use-package json-mode)
#+end_src

* [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]                                               :keybinding:
:PROPERTIES:
:REPO:     https://github.com/magnars/multiple-cursors.el
:END:

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :config
    (define-key mc/keymap (kbd "<return>") nil)
    (setq mc/always-run-for-all t
          mc/always-repeat-command t)
    :bind
    ("C->" . 'mc/mark-next-like-this-symbol)
    ("C-<" . 'mc/mark-previous-like-this-symbol)
    ("C-S-n" . 'mc/mark-next-like-this)
    ("C-S-p" . 'mc/mark-previous-like-this)
    ("C-S-a" . 'mc/mark-all-like-this))
#+END_SRC

* Spell checker

Enable regular spell checking in all text modes and prog type spell
checking in prog modes:
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)
  (add-hook 'text-mode-hook 'flyspell-mode)
#+end_src

* Edit-indirect
:PROPERTIES:
:REPO:     https://github.com/Fanael/edit-indirect
:END:

To edit arbitrary code in separate buffers (the same way org mode
does), the package edit-indirect exist. This is required by markdown
mode to edit source code blocks in separate buffers.

#+begin_src emacs-lisp
  (use-package edit-indirect)
#+end_src

* Markdown mode
:PROPERTIES:
:REPO:     https://github.com/jrblevin/markdown-mode
:END:

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("\\.md\\'" . gfm-mode))
    :after
    (edit-indirect)
    :config
    (setq markdown-asymmetric-header t))
#+end_src

* link-hint
:PROPERTIES:
:REPO:     https://github.com/noctuid/link-hint.el
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-13 Thu 18:06]
:END:

Link-hint allows you to open any links in the current frame by
typing a sequence of letters indicated by an overlay.
#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :general
    (:prefix "C-x l"
             "o" 'link-hint-open-link
             "c" 'link-hint-copy-link))
#+END_SRC

* Vim-like isearch motions

As outlined in [[https://blog.thomasheartman.com/posts/my-first-emacs-lisp][this blog post]], I don't really like how isearch jumps
to the end of the search string when jumping forwards. At least not
as a general rule. I prefer Vim's style of searching, where you're
always placed at the beginning of the term. So I wrote some code to
deal with that.

In addition to defining of extra functions for copying and
deleting the selected text, Vim-style, we'll also remap the default
~isearch-exit~ binding (~<return>~), to use the Vim-style binding
instead. In the event that I want to use the default isearch exit
functionality, let's bind that to something else.

#+begin_src emacs-lisp
  (defun isearch-vim-style-exit ()
    "Move point to the start of the matched string, regardless
    of search direction."
    (interactive)
    (when (eq isearch-forward t)
      (goto-char isearch-other-end))
    (isearch-exit))

  (defun isearch-vim-style-kill ()
    "Kill up to the search match when searching forward. When
    searching backward, kill to the beginning of the match."
    (interactive)
    (isearch-vim-style-exit)
    (call-interactively 'kill-region))

  (defun isearch-vim-style-copy ()
    "Copy up to the search match when searching forward. When
    searching backward, copy to the start of the search match."
    (interactive)
    (isearch-vim-style-exit)
    (call-interactively 'kill-ring-save)
    (exchange-point-and-mark))

  (defun my-define-key (map binding func)
    (define-key map (kbd binding) func))

  (define-key isearch-mode-map (kbd "<return>") 'isearch-vim-style-exit)
  (define-key isearch-mode-map (kbd "<C-return>") 'isearch-exit)
  (define-key isearch-mode-map (kbd "C-k") 'isearch-vim-style-kill)
  (define-key isearch-mode-map (kbd "<C-M-return>") 'isearch-vim-style-copy)
#+end_src

* expand-region
:PROPERTIES:
:REPO:     https://github.com/magnars/expand-region.el
:END:

Expand-region increases the selected region by semantic units.
#+begin_src emacs-lisp
  (use-package expand-region
    :bind
    ("C-=" . 'er/expand-region)
    ("C-M-=" . 'er/contract-region))
#+end_src

* Org mode

** Getting Things Done (GTD)                                            :GTD:

Because I am working on implementing the GTD methodology, I want to configure org mode to work with this as easily as possible. This section is based heavily on [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][this blog post]] by Nicolas Petton over at [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][Emacs Café]].

*** Capture templates

Configure capture templates to use for adding new entries to the inbox.
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("i" "Inbox (GTD)" entry (file "~/gtd/inbox.org")
           "* %^{title}\n:LOGBOOK:\n- Created %U\n:END:\n\n%i%?" :empty-lines 1)
          ("p" "Project (GTD)" entry (file+headline "~/gtd/main.org" "Tasks")
           "* %^{title} [/]\n:LOGBOOK:\n- Created %U\n:END:\n%i%?" :empty-lines 1)))
#+end_src

*** Refile targets

Configure refile targets for when moving items from the inbox to their correct positions. The ~(nil :maxlevel . N)~ entry means that the current file will also be searched for refile targets, and the ~(org-buffer-list :maxlevel . N)~ entry means that any org buffer is also used for targets.
#+begin_src emacs-lisp
  (setq org-refile-targets '((nil :maxlevel . 5)
                             (org-buffer-list :maxlevel . 2)
                             ("~/gtd/main.org" :maxlevel . 5)
                             ("~/gtd/someday-maybe.org" :level . 1)
                             ("~/gtd/tickler.org" :maxlevel . 2)))
#+end_src

*** Tags

I want to set up set of common tags. We'll define a group of mutually exclusive tags (prefixed with an '@') for /context/, and another set of tags for categories.
#+begin_src emacs-lisp
  (setq org-tag-alist '((:startgroup)
                        ("@errand" . ?e)
                        ("@office" . ?o)
                        ("@home" . ?h)
                        ("@computer" . ?c)
                        ("@phone" . ?9)
                        (:endgroup)
                        (:newline)
                        (:startgroup)
                        ("fitness" . ?f)
                        (:grouptags)
                        (:startgroup)
                        ("LesMills" . ?L)
                        (:grouptags)
                        ("SHBAM" . ?S)
                        ("BODYATTACK" . ?A)
                        ("BODYCOMBAT" . ?C)
                        ("BODYPUMP" .?P)
                        ("BODYJAM" .?J)
                        ("GRIT" .?G)
                        (:endgroup)
                        (:endgroup)
                        (:startgroup)
                        ("website" . ?s)
                        (:grouptags)
                        ("blog" . ?b)
                        (:endgroup)
                        (:startgroup)
                        ("work" . ?W)
                        (:grouptags)
                        ("enonic" . ?E)
                        ("logrocket")
                        (:endgroup)
                        (:startgroup)
                        ("home" . ?H)
                        (:grouptags)
                        ("clothing")
                        (:endgroup)
                        ("finance" . ?F)
                        ("personal" . ?p)
                        ("design" . ?D)
                        (:startgroup)
                        ("review" . ?r)
                        (:grouptags)
                        ("watch")
                        ("read")
                        ("listen")
                        (:endgroup)
                        ("wishlist" . ?w)
                        ("dev" . ?d)
                        ("GTD" . ?g)
                        ("productivity")))
#+end_src

I also want to enable setting tags with a single press and without a pop-up menu:
#+begin_src emacs-lisp
  (setq org-use-fast-tag-selection t)
  (setq org-fast-tag-selection-single-key t)
#+end_src

*** todo keywords

Here's the set of keywords I use for tracking states for my list items:
#+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO(t!)" "NEXT(n!)" "WAITING(w@)" "|" "DONE(d!)" "CANCELED(c!)")))
#+end_src

*** key bindings                                                 :keybinding:

Since let's also define some sensible bindings for org mode! In
particular, let's make it easy to create capture templates and to
view the agenda.
#+BEGIN_SRC emacs-lisp
  (my-app-def
    "c" 'org-capture
    "a" 'org-agenda)
#+END_SRC

** Agenda

*** Agenda files                                                        :GTD:

We only want to show agenda items from the GTD files where actual items lie, so there's no some day / maybe list included.
#+begin_src emacs-lisp
  (setq org-agenda-files '("~/gtd/inbox.org"
                           "~/gtd/main.org"
                           "~/gtd/tickler.org"))
#+end_src



*** Custom commands

Let's create some custom commands to use with the agenda view:
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        '(("w" "Work" tags-todo "work")
          ("b" "Blog" tags-todo "blog")
          ("e" "Emacs" tags-todo "emacs")
          ("o" "Org" tags-todo "org")
          ("g" "GTD" tags-todo "GTD")))
#+end_src

*** Weekly view

For the weekly view, instead of seeing the current week (Monday through Sunday), I prefer seeing the next ~n~ and the previous ~m~ days.
#+begin_src emacs-lisp
  (setq org-agenda-start-on-weekday nil
        org-agenda-span 10
        org-agenda-start-day "-3d")
#+end_src

*** Scheduling

Org has an option to not show repeated scheduling info after
deadlines, which essentially acts as a 'repeat until' date.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-skip-scheduled-if-deadline-is-shown 'repeated-after-deadline)
#+END_SRC


** Org-ref

I use [[https://github.com/jkitchin/org-ref][org-ref]] for managing bibliographies and citations.

#+begin_src emacs-lisp
  (use-package org-ref
    :after org
    :init (setq reftex-default-bibliography'("~/gtd/bibliography/references.bib")
                org-ref-bibliography-notes "~/gtd/bibliography/notes.org"
                org-ref-default-bibliography'("~/gtd/bibliography/references.bib")
                org-ref-pdf-directory "~/gtd/bibliography/bibtex-pdfs/"
                bibtex-completion-bibliography "~/gtd/bibliography/references.bib"
                bibtex-completion-library-path "~/gtd/bibliography/bibtex-pdfs"
                bibtex-completion-notes-path "~/gtd/bibliography/helm-bibtext-notes"))
#+end_src

** Babel

In addition to the basic org-babel setup, we can add some more
languages and a couple extra packages to make it even smoother to
work with.

First off, let's add some more languages.
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)))
#+END_SRC

One such package is [[https://github.com/zweifisch/ob-http][ob-http]], which allows you to make HTTP requests from org source blocks:
#+begin_src emacs-lisp
  (use-package ob-http
    :init (add-to-list 'org-babel-load-languages '(http . t)))
#+end_src


#+BEGIN_SRC emacs-lisp
  (use-package ob-rust
    :init (add-to-list 'org-babel-load-languages '(rust . t)))
#+END_SRC


Because I trust myself (somewhat foolishly perhaps) to only execute org code
blocks that I know to be safe, I don't want to be prompted when executing a code block:
#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

** Other settings

I like seeing symbols in my buffer, rather than LaTeX commands.
This makes '\alpha + \pi' look like 'α + π' and also displays sub- and
superscripts properly.

#+begin_src emacs-lisp
  (setq org-pretty-entities t)
#+end_src

I also want my footnotes to be automatically sorted and renumbered whenever I insert a new one.
#+begin_src emacs-lisp
  (setq org-footnote-auto-adjust t)
#+end_src


Furthermore, I /always/ want to org to log into drawers, so let's set that too:
#+begin_src emacs-lisp
  (setq org-log-into-drawer t)
#+end_src

While I like electric-pair-mode, the fact that ~<~ inserts a
closing ~>~ is an issue for templates. This code is based on [[https://www.topbug.net/blog/2016/09/29/emacs-disable-certain-pairs-for-electric-pair-mode/][this
blog post]].

#+begin_src emacs-lisp :tangle no
  (defun my-org-mode-hook ()
    (setq-local electric-pair-inhibit-predicate
                `(lambda (c)
                   (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))))
  (add-hook 'org-mode-hook 'my-org-mode-hook)
#+end_src

** Additional keybindings                                        :keybinding:

There some org functionality that's not bound to anything by
default, so let's see what we can do about that.

#+BEGIN_SRC emacs-lisp
  (general-def
    :keymaps 'org-mode-map
    "C-c _" 'org-toggle-timestamp-type
    "C-a" 'my-move-beginning-of-line)

  (general-create-definer my-org-item-def
    :keymaps 'org-mode-map
    :prefix "C-c i")

  (my-org-item-def
    "a" 'org-beginning-of-item
    "e" 'org-end-of-item
    "n" 'org-next-item
    "p" 'org-previous-item
    "i" 'org-insert-item
    "<tab>" 'org-indent-item
    "<backtab>" 'org-outdent-item
    "t" 'org-toggle-item)

  (my-link-def
    "s" 'org-store-link)
#+END_SRC



** Focus next heading

When working through large org files, I find it useful to focus on
only a single subtree at a time. Often, I want to close all other
subtrees and only see this one. We can write a function for that.

#+BEGIN_SRC emacs-lisp
  (defvar my-org-heading-navigation-show-headings-only nil
    "t if movement should show just subheadings and not content.")

  (defun my-org-open-heading-base (arg motion)
    (when arg
      (setq
       my-org-heading-navigation-show-headings-only
       (not my-org-heading-navigation-show-headings-only)))
    (let ((show-contents
           (if my-org-heading-navigation-show-headings-only
               'outline-show-children
             'outline-show-subtree)))
      (outline-hide-sublevels (org-outline-level))
      (funcall motion 1)
      (funcall show-contents)))

  (defun my-org-open-next-heading (arg)
    "Close the current heading and open the next one.

  If ARG is non-nil, only show subheadings of the next heading
  instead of the entire subtree."
    (interactive "P")
    (my-org-open-heading-base arg 'org-forward-heading-same-level))

  (defun my-org-open-previous-heading (arg)
    "Close the current heading and open the previous one.

  If ARG is non-nil, only show subheadings of the previous heading
  instead of the entire subtree."
    (interactive "P")
    (my-org-open-heading-base arg 'org-backward-heading-same-level))

  (general-def
    org-mode-map
    "<prior>" 'my-org-open-previous-heading
    "<next>" 'my-org-open-next-heading)
#+END_SRC

** TODO Toggle subtree visibility
:LOGBOOK:
- State "TODO"       from              [2021-03-18 Thu 08:54] \\
  Make it possible to toggle directly from children to subtree (without
  closing in between).
:END:


#+BEGIN_SRC emacs-lisp
  (defun heartman/toggle-heading-content (show-children)
    "Toggle the current heading's subtree visibility.

  With a prefix arg, toggle children instead."
    (interactive "P")
    (if show-children
        (outline-toggle-children)
      (pdf-outline-toggle-subtree)))

  (general-def
    org-mode-map
    "C-<tab>" 'heartman/toggle-heading-content
    "C-S-<iso-lefttab>" 'outline-hide-subtree)
#+END_SRC

** templates (org-tempo)
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-08-13 Thu 09:29]
- State "TODO"       from "TODO"       [2020-08-13 Thu 09:29]
- State "TODO"       from              [2020-08-12 Wed 14:52]
:END:

To reclaim the functionality of expanding ~<s~, ~<q~ and others
into org blocks, we need to add ~org-tempo~ to the list of
org-modules. More info is found in the Reddit thread [[https://www.reddit.com/r/emacs/comments/ad68zk/get_easytemplates_back_in_orgmode_92/][Get
easy-templates back in org-mode 9.2]].

Because org-tempo might not be available before 9.2, let's only add
it if it /is/ available.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-modules 'org-tempo)
#+END_SRC

** Configuration:
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-08-20 Thu 21:11]
- State "TODO"       from              [2020-08-18 Tue 19:16]
:END:

The default value of ~org-src-window-setup~ reshuffles the whole
frame when you edit a source block. I find this to be both annoying
and disturbing, so let's instead have org mode simply create a new
window for it.

Additionally, we can also have ~C-a~, ~C-e~, and ~C-k~ adapt to
whether they're being invoked in a headline or not.
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'split-window-right
        org-special-ctrl-a/e t
        org-special-ctrl-k t)
#+END_SRC


** Overrides

Based on [[https://stackoverflow.com/a/54251825][this Stack Overflow answer]], we can make org-capture not
delete other windows by redefining some functionality before
calling it:
#+BEGIN_SRC emacs-lisp
  (defun my-org-capture-place-template (oldfun args)
    (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
      (apply oldfun args)))

  (with-eval-after-load "org-capture"
    (advice-add 'org-capture-place-template :around 'my-org-capture-place-template))
#+END_SRC

** Org-rifle
:PROPERTIES:
:REPO:     https://github.com/alphapapa/org-rifle
:END:

#+BEGIN_SRC emacs-lisp
  (use-package helm-org-rifle
    :general
    (my-app-def
      "r" 'helm-org-rifle-agenda-files))
#+END_SRC

** TODO Formatting
:LOGBOOK:
- State "TODO"       from "TODO"       [2021-03-17 Wed 12:03] \\
  Wish list:
  - Stop this from inserting blank lines above the first heading if there
  is no content before it
  - Indent content correctly
  - Delete extra whitespace between content and headings
- State "TODO"       from              [2020-09-09 Wed 14:26] \\
  Find out how to make before-save-hook actually work.
:END:

#+BEGIN_SRC emacs-lisp
  (defun unpackaged/org-fix-blank-lines ()
    "Ensure that blank lines exist between headings and between
  headings and their contents. Operates on whole buffer."
    (interactive)
    (org-map-entries (lambda ()
                       (org-with-wide-buffer
                        ;; `org-map-entries' narrows the buffer, which prevents us from seeing
                        ;; newlines before the current heading, so we do this part widened.
                        (while (not (looking-back "\n\n" nil))
                          ;; Insert blank lines before heading.
                          (insert "\n")))
                       (let ((end (org-entry-end-position)))
                         ;; Insert blank lines before entry content
                         (forward-line)
                         (while (and (org-at-planning-p)
                                     (< (point) (point-max)))
                           ;; Skip planning lines
                           (forward-line))
                         (while (re-search-forward org-drawer-regexp end t)
                           ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
                           ;; for some reason it doesn't work correctly when operating on hidden text.
                           ;; This works, taken from `org-agenda-get-some-entry-text'.
                           (re-search-forward "^[ \t]*:END:.*\n?" end t)
                           (goto-char (match-end 0)))
                         (unless (or (= (point) (point-max))
                                     (org-at-heading-p)
                                     (looking-at-p "\n"))
                           (insert "\n"))))
                     t nil))
  (general-def
    :keymaps 'org-mode-map
    my-format-buffer 'unpackaged/org-fix-blank-lines)
#+END_SRC

I don't like to have to remember to format my document, so I'd
rather it be done automatically before saving:

#+BEGIN_SRC emacs-lisp
  (defun my-org-mode-hook ()
    (add-hook 'before-save-hook #'unpackaged/org-fix-blank-lines nil 'local))

  (add-hook 'org-mode-hook #'my-org-mode-hook)
#+END_SRC

** org-indent-mode

We can make org mode use only visual indentation (instead of hard
spaces). This makes working with external apps (Beorg) that don't
support automatic indentation easier, and also smooths out working
with mixed pitches.

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
#+END_SRC


** TODO org-plus-contrib
:LOGBOOK:
- State "TODO"       from "TODO"       [2020-08-30 Sun 14:26] \\
  Make this work somehow.

  I tested in on NixOS just now, but with no luck. Trying to require
  'org-contrib threw an error saying the file couldn't be found. I'm not
  ready to spend a lot of time on this just now, so look at it again
  some other time.
- State "TODO"       from              [2020-08-30 Sun 14:19] \\
  Figure out how this works with macos.
:END:

To be able to store links to notmuch emails, we can require
org-notmuch. However, this requires that we add the contrib
directory to load path. [[https://notmuchmail.org/emacstips/][According to the notmuch manual]], this can
be done like this on NixOS:
#+BEGIN_SRC emacs-lisp :tangle no
  (loop for p in load-path
        do (if (file-accessible-directory-p p)
               (let ((m (directory-files-recursively p "^org-notmuch.el$")))
                 (if m (add-to-list 'load-path (file-name-directory (car m)))))))


  ;; (require 'org-notmuch)
#+END_SRC

** Jump to content

When at a heading (or working in the subtree of one), I'd like a
quick way to jump to the start of the current content section. That
is:
- if the heading has no content after it, create a new line and indent
- if the heading has content following, place the cursor at the
  start of this content

  If the heading has metadata, this should be skipped.

  #+BEGIN_SRC emacs-lisp
    (defun heartman/org-jump-to-content ()
      "Jump to content below current heading.

    If there is no content, place the cursor where it should start."
      (interactive)
      (org-back-to-heading)
      (let ((heading-line (line-number-at-pos)))
        (org-end-of-meta-data t)
        (cond
         ;; the cursor is not at the first column. this means we're at the
         ;; end of a line for some reason, most likely at the end of a
         ;; heading or a drawer.
         ((not (= 0 (current-column)))
          (newline 2))
         ;; we're at a heading
         ((org-at-heading-p)
          (open-line 1)
          (delete-blank-lines)
          (open-line 1)
          (newline))
         ;; if the current line is empty
         ((looking-at-p "[[:space:]]*$")
          (delete-blank-lines)
          (newline)))
        (org-indent-line)))

    (general-def
      org-mode-map
      "C-c C-r" 'heartman/org-jump-to-content)
  #+END_SRC

** org-open-line

By default, ~org-open-line~ uses the normal ~open-line~ function to
open a line. However, I'd like it to also indent the line it has
opened (see the [[*Open line]['Open line' heading]]),  so let's create a custom definition for that.

#+BEGIN_SRC emacs-lisp
  (defun heartman/org-open-line (n)
    "Insert a new row in tables, call `my-open-line' elsewhere.
  If `org-special-ctrl-o' is nil, just call `my-open-line' everywhere.
  As a special case, when a document starts with a table, allow to
  call `my-open-line' on the very first character."
    (interactive "*p")
    (if (and org-special-ctrl-o (/= (point) 1) (org-at-table-p))
        (org-table-insert-row)
      (my-open-line n)))

  (general-def
    :keymaps 'org-mode-map
    "C-o" 'heartman/org-open-line)
#+END_SRC


** Org export

*** TODO GFM (ox-gfm)
:PROPERTIES:
:REPO:     https://github.com/larstvei/ox-gfm
:END:
:LOGBOOK:
- State "TODO"       from              [2020-10-27 Tue 23:33] \\
  Make sure that this is auto-loaded with org-mode.
:END:

ox-gfm exports org mode documents to GitHub flavored markdown.
This has several improvements over the default Emacs markdown
export, including source code language and triple back ticks.

#+BEGIN_SRC emacs-lisp
  (use-package ox-gfm)
#+END_SRC

*** Variable pitch
:PROPERTIES:
:REPO:     https://github.com/cadadr/elisp
:END:

#+BEGIN_SRC emacs-lisp
  (use-package org-variable-pitch
    :straight (:host github
                     :repo "cadadr/elisp"
                     :files ("org-variable-pitch.el"))
    :config
    (setq ovp-mono-faces nil)
    :hook
    (org-mode . org-variable-pitch-minor-mode))
#+END_SRC

*** Latex templates

Org mode lets you define your own latex templates that can be used
when exporting latex.

**** UiO / MAT2250

This template is used for maths assignments at UiO.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-latex-classes
               '("uio-memoir"
                 "
  \\documentclass[a4paper,
                 12pt,
                 article,
                 oneside,
                 oldfontcommands]{memoir}

  [NO-DEFAULT-PACKAGES]

  \\usepackage[utf8]{inputenc}
  \\usepackage[T1]{fontenc}
  \\usepackage{lmodern}
  \\usepackage[scaled]{beramono}
  \\usepackage[final]{microtype}
  \\usepackage{amssymb}
  \\usepackage{mathtools}
  \\usepackage{amsthm}
  \\usepackage{thmtools}
  \\usepackage{babel}
  \\usepackage{csquotes}
  \\usepackage[nodayofweek]{datetime}
  \\usepackage{listings}
  \\lstset{basicstyle = \\ttfamily}
  \\usepackage{textcomp}
  \\usepackage{siunitx}
  \\usepackage{xcolor}
  \\usepackage{graphicx}
  \\usepackage[colorlinks, allcolors = uiolink]{hyperref}




  \\usepackage{tikz}
  \\usetikzlibrary{
    graphs,
    graphs.standard
  }
  \\renewcommand*{\\chaptitlefont}{\\Large\\bfseries\\sffamily\\raggedright}
  \\setsecheadstyle{\\large\\bfseries\\sffamily\\raggedright}
  \\setsubsecheadstyle{\\large\\bfseries\\sffamily\\raggedright}
  \\setsubsubsecheadstyle{\\normalsize\\bfseries\\sffamily\\raggedright}
  \\setparaheadstyle{\\normalsize\\bfseries\\sffamily\\raggedright}
  \\setsubparaheadstyle{\\normalsize\\bfseries\\sffamily\\raggedright}
  \\setbeforesubsubsecskip{2ex}
  \\setaftersubsubsecskip{1ex}


  \\pretolerance = 2000
  \\tolerance    = 6000
  \\hbadness     = 6000


  \\renewcommand{\\sfdefault}{phv}
  \\definecolor{uiolink}{HTML}{0B5A9D}


  \\declaretheorem[style = definition]{problem}
  \\declaretheorem[style = definition, sibling = problem]{exercise}

  \\newenvironment{answer}
  {
  \\textbf{Answer}

  }
  {

  }

  \\DeclarePairedDelimiter\\ceil{\\lceil}{\\rceil}
  \\DeclarePairedDelimiter\\floor{\\lfloor}{\\rfloor}
  "
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC


* Yasnippet
:PROPERTIES:
:REPO:     https://github.com/joaotavora/yasnippet
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-12 Wed 14:46]
:END:

For some reason, snippets didn't seem to be loading properly, so I
added reload directive to force reload.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1)
    (yas-reload-all))
#+END_SRC

* Hydra
:PROPERTIES:
:REPO:     https://github.com/abo-abo/hydra
:END:

#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :demand t
    :after eyebrowse
    :config
    (defhydra hydra-window-movement (global-map "C-x w")
      "
  Move    ^^Split     ^^Resize            ^^Other
  ------------------------------------------------------
  _←_: ←    _|_: right    _m_: maximize       _b_: switch buffer
  _↓_: ↓    ___: below    _D_: ace-delete     _f_: find file
  _↑_: ↑    _u_: undo     _d_: del window   ^^SPC: app launcher
  _→_: →    _U_: redo     _w_: balance
                    ^^_h_/_H_: grow left
                    ^^_l_/_L_: grow right
                    ^^_k_/_K_: grow up
                    ^^_j_/_J_: grow down
                  ^^^^    _z_: max horiz
                  ^^^^    _v_: max vert

  _a_: ace-window _q_: quit
  "
      ("<up>" windmove-up)
      ("<down>" windmove-down)
      ("<left>" windmove-left)
      ("<right>" windmove-right)

      ("|" split-window-right-and-focus)
      ("_" split-window-below-and-focus)
      ("u" winner-undo)
      ("U" winner-redo)

      ("m" my-maximize-or-undo-window)
      ("D" ace-delete-window)
      ("d" delete-window)
      ("w" balance-windows)
      ("h" delete-window-left)
      ("H" delete-windows-to-the-left)
      ("l" delete-window-right)
      ("L" delete-windows-to-the-right)
      ("k" delete-window-up)
      ("K" delete-windows-above)
      ("j" delete-window-down)
      ("J" delete-windows-below)
      ("z" maximize-window-horizontally)
      ("v" maximize-window-vertically )

      ("b" switch-to-buffer)
      ("f" find-file)
      ("<SPC>" my-exwm-launcher)

      ;; eyebrowse
      (">" eyebrowse-next-window-config)
      ("<" eyebrowse-prev-window-config)
      ("." eyebrowse-switch-to-window-config)
      ("," eyebrowse-rename-window-config)
      ("'" eyebrowse-last-window-config)
      ("\"" eyebrowse-close-window-config)
      ("c" eyebrowse-create-window-config)

      ;; projectile
      ("p" projectile-switch-project)
      ("F" projectile-find-file)

      ;; transpose-frame
      ("t" rotate-frame-clockwise)
      ("T" rotate-frame-anticlockwise)
      ("r" rotate-frame)

      ("a" ace-window)
      ("q" nil))
    (hydra-set-property 'hydra-window-movement :verbosity 0))
#+END_SRC

* ace-window
:PROPERTIES:
:REPO:     https://github.com/abo-abo/ace-window
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-13 Thu 09:32]
:END:

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :config
    (setq aw-dispatch-always t))
#+END_SRC

* Smartparens
:PROPERTIES:
:REPO:     https://github.com/Fuco1/smartparens
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-12 Wed 22:13]
:END:

This setup is heavily inspired by [[https://gist.github.com/oantolin/5751fbaa7b8ab4f9570893f2adfe1862][this Gist]], which was linked to
from [[https://www.reddit.com/r/emacs/comments/6j2s95/i_still_cant_find_an_efficient_and_simple/][this Reddit thread]] about smartparens configs. Further, [[https://ebzzry.io/en/emacs-pairs/][this
blog post]] contains a number of well-illustrated examples of how the
movement works.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :init
    (smartparens-global-mode)
    :hook (eval-expression-minibuffer-setup . smartparens-mode)
    (eshell-mode . smartparens-mode)
    :general
    (:keymaps 'smartparens-mode-map
              "C-S-e" 'sp-end-of-sexp
              "C-S-a" 'sp-beginning-of-sexp
              "C-S-f" 'sp-forward-symbol
              "C-S-b" 'sp-backward-symbol
              "C-M-," 'sp-rewrap-sexp
              "C-M-;" (lambda ()
                        (interactive)
                        (save-excursion
                          (sp-select-next-thing-exchange)
                          (comment-region (region-beginning) (region-end)))))
    :custom
    (sp-base-key-bindings 'sp)
    :config
    (require 'smartparens-config)
    (sp-local-pair 'csharp-mode "<" ">")
    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
#+END_SRC

* [[https://github.com/smihica/emmet-mode][emmet-mode]]
:PROPERTIES:
:REPO:     https://github.com/smihica/emmet-mode
:END:

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :hook
    html-mode)
#+END_SRC


* Editorconfig
:PROPERTIES:
:REPO:     https://github.com/editorconfig/editorconfig-emacs
:END:

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :config
    (editorconfig-mode 1))
#+END_SRC

* TODO Notmuch
:PROPERTIES:
:WEBSITE:  [[https://notmuchmail.org/][Notmuch]] [[https://notmuchmail.org/notmuch-emacs/][Notmuch-emacs]]
:END:
:LOGBOOK:
- State "TODO"       from              [2021-02-04 Thu 21:16] \\
  The email attachment scanning doesn't account for whether the found
  text is in the response body or in the quoted text. So even if someone
  else has mentioned attachments it'll get triggered. To improve this,
  we should only scan the text from

  #+begin_example
  --text follows this line--
  #+end_example

  and to

  #+begin_example
    name <email> writes:

    >
  #+end_example

  or, in the event that there is no name:
  #+begin_example
    xyz@host.tld writes:

    >
  #+end_example
:END:

#+BEGIN_SRC emacs-lisp
  (use-package notmuch
    :hook
    (notmuch-search . (lambda () (toggle-truncate-lines 1)))
    (notmuch-message-mode . (lambda ()
                              (auto-fill-mode -1)
                              (company-emoji-init)))
    :general
    (my-app-def
      "m" 'notmuch)
    (notmuch-hello-mode-map
     "f" 'fetch-mail-poll-and-refresh)
    (notmuch-search-mode-map
     "f" 'fetch-mail-poll-and-refresh)
    :custom
    (notmuch-search-oldest-first nil)
    (mail-specify-envelope-from t)
    (message-sendmail-envelope-from 'header)
    (mail-envelope-from 'header)
    (notmuch-hello-sections
     '(notmuch-hello-insert-saved-searches
       notmuch-hello-insert-recent-searches
       notmuch-hello-insert-alltags
       notmuch-hello-insert-footer))
    (notmuch-saved-searches
     '((:name "inbox" :query "tag:inbox" :key "i")
       (:name "unread" :query "tag:unread" :key "u")
       (:name "flagged" :query "tag:flagged" :key "f")
       (:name "sent" :query "tag:sent" :key "s")
       (:name "drafts" :query "tag:draft" :key "d")
       (:name "all mail" :query "*" :key "a")
       (:name "gheart"
              :query "to:@gmail.com"
              :key "g")
       (:name "gheart (unread)"
              :query "to:@gmail.com AND tag:unread"
              :key "G")
       (:name "enonic"
              :query "to:@enonic.com"
              :key "e")
       (:name "enonic (unread)"
              :query "to:@enonic.com AND tag:unread"
              :key "E")))
    :init

    (defvar heartman/fetch-mail-process-prefix
      "heartman-fetch-mail"
      "A string to prefix custom mail polling processes with.

  Created as a variable to let me detect already-running
  processes.")
    (defun fetch-mail-poll-and-refresh ()
      "Pull new mail from the server and update the current buffer."
      (interactive)
      (when
          (seq-some
           (lambda (p)
             (string-match-p
              (format "%s-.+" heartman/fetch-mail-process-prefix)
              (process-name p)))
           (process-list))
        (user-error "A mail poll is already in progress"))
      (notmuch-refresh-this-buffer)
      (message "Fetching new mail from the server.")
      (let ((accounts
             <<notmuch-get-account-names>>))
        (dolist (account accounts)
          <<notmuch-fetch-mail>>)))
    :config
    (setq message-send-mail-function 'message-send-mail-with-sendmail
          notmuch-fcc-dirs "sent +sent -unread -inbox")

    ;; based on https://notmuchmail.org/pipermail/notmuch/2018/026414.html
    (defcustom notmuch-message-attachment-regex
      "\\b\\(\\(attach\\(ment\\|ed\\)?\\|ved\\(legg\\(et\\)?\\|lagt\\)\\)\\|\\(\\(lagt\\|legg\\(e\\(r\\)?\\)?\\) ?+ved\\)\\)\\b"
      "Regex to check against for attachments.

  This is used by `notmuch-message-check-for-attachments' to check email
  bodies for words that might indicate the email should have an
  attachment. If the pattern matches and there is no attachment (a
  <#part ...> magic block), notmuch will show a confirmation prompt
  before sending the email.

  The above regex is liberal on purpose. We'd rather trigger once
  too often than not often enough. This version checks for English
  and Norwegian."
      :type '(regexp)
      :group 'notmuch-send)

    (defun notmuch-message-check-for-attachments ()
      "Check for missing attachments.

  This executes on `message-send-hook' and is configured via `notmuch-message-attachment-regex'"
      (save-mark-and-excursion
        (goto-char (point-min))
        (when (re-search-forward notmuch-message-attachment-regex nil t)
          (progn
            (goto-char (point-min))
            (unless (re-search-forward "<#part [^>]*filename=[^>]*>" nil t)
              (or (y-or-n-p "It seems this email is referring to attachment, but there's nothing attached. Send anyways? ")
                  (error "No attachment found. Aborting")))))))

    (add-hook 'message-send-hook 'notmuch-message-check-for-attachments))
#+END_SRC

** offlineimap functions
:PROPERTIES:
:header-args: :tangle no
:END:

To improve the mail fetching and polling operation, let's
parallelize the requests if there are multiple accounts.

First, we'll need to find out what accounts there are:

#+name: notmuch-get-account-names
#+BEGIN_SRC emacs-lisp
  (with-temp-buffer
    (insert-file-contents "~/.config/offlineimap/config")
    (let* ((lines (split-string (buffer-string) "\n" t))
           (key "accounts = ")
           (matches (seq-filter (lambda (l) (string-match-p key l)) lines))
           (trimmed (mapcar (lambda (l) (string-remove-prefix key l)) matches)))
      (mapcan (lambda (l) (split-string l "," nil " +")) trimmed)))
#+END_SRC

Next, we'll want to create a sentinel for fetching each of the
accounts. Also, to speed it up, we'll only run quick syncs.

#+name: notmuch-fetch-mail
#+BEGIN_SRC emacs-lisp :var account="notmuch-account"
  (set-process-sentinel
   (start-process
    (format "%s-%s" heartman/fetch-mail-process-prefix account)
    (format "*OFFLINEIMAP-QUICK-SYNC-%s" account)
    "offlineimap" "-o" "-q" "-a" account)
   (lambda (p e) (when (= 0 (process-exit-status p))
                   (notmuch-poll-and-refresh-this-buffer))))
#+END_SRC

** gnus-alias

To make handling of multiple identities (really: signatures)
easier, we can use gnus-alias.

#+BEGIN_SRC emacs-lisp
  (use-package gnus-alias
    :config
    (setq gnus-alias-identity-alist
          '(("gheart"
             nil
             "Thomas Heartman <thomasheartman@gmail.com>"
             nil
             nil
             nil
             "~/.signatures/signature.gheart")
            ("enonic"
             nil
             "Thomas Heartman <the@enonic.com>"
             nil
             nil
             nil
             "~/.signatures/signature.enonic"))
          gnus-alias-default-identity "gheart"
          gnus-alias-identity-rules '(("enonic" ("From" "the@enonic.com" both) "enonic")))

    :hook
    (message-setup . gnus-alias-determine-identity))
#+END_SRC


* TODO Elfeed
:PROPERTIES:
:REPO:     https://github.com/skeeto/elfeed
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-20 Thu 21:15] \\
  Find out how to change the layout of the feeds view. Spacemacs does it
  somehow. The current layout causes a lot of double lines etc.
:END:


** Elfeed-org
:PROPERTIES:
:REPO:     https://github.com/remyhonig/elfeed-org
:END:

#+BEGIN_SRC emacs-lisp
  (if (string= "N/A" org-version)
      (message "Not loading elfeed; org-version is 'N/A")
    (defun heartman/elfeed-operate-on-all-entries (operation)
      "Perform operation on all visible entries."
      (lambda ()
        (interactive)
        (save-excursion
          (mark-whole-buffer)
          (call-interactively operation))))
    (use-package elfeed-org
      :custom
      (elfeed-sort-order 'ascending)
      :init
      (elfeed-org)
      :hook
      (elfeed-search-mode . (lambda () (toggle-truncate-lines 1)))
      :general
      (my-app-def
        "f" 'elfeed)
      (elfeed-search-mode-map
       "v" 'set-mark-command
       "R" (heartman/elfeed-operate-on-all-entries #'elfeed-search-untag-all-unread)
       "B" (heartman/elfeed-operate-on-all-entries #'elfeed-search-browse-url))
      :config
      (setq rmh-elfeed-org-files '("~/feeds.org")
            elfeed-search-filter "@2-weeks-ago +unread")))
#+END_SRC


** Elfeed-goodies
:PROPERTIES:
:REPO:     https://github.com/algernon/elfeed-goodies
:END:

elfeed-goodies offers certain nice features, but most important is
how it reorders the columns in the elfeed buffer.

#+BEGIN_SRC emacs-lisp
  (unless (string= "N/A" org-version)
    (use-package elfeed-goodies
      :after elfeed
      :config
      (elfeed-goodies/setup)))
#+END_SRC


* Origami
:PROPERTIES:
:REPO:     https://github.com/gregsexton/origami.el
:END:

Origami provides code folding.
#+BEGIN_SRC emacs-lisp
  (use-package origami
    :bind
    ("<C-M-tab>" . origami-recursively-toggle-node)
    :init
    (global-origami-mode)
    :config
    (setq origami-parser-alist
          (append origami-parser-alist
                  '((rust-mode . origami-c-style-parser)))))
#+END_SRC


* eyebrowse
:properties:
:repo:     [[https://depp.brause.cc/eyebrowse/][depp.brause.cc]]
:end:

i'm trying out eyebrowse for a while. I've had some issues with it
not working properly with X windows, but I'll try it out and see how
I get on.

because i've got all the functionality i want mapped in my window
hydra, i'll disable the regular ~eyebrowse-keymap-prefix~ by binding
it to a pretty stupid binding.
#+BEGIN_SRC emacs-lisp
  (use-package eyebrowse
    :init (setq-default eyebrowse-keymap-prefix (kbd "C-c M-C-S-e"))
    :demand t
    :config
    (eyebrowse-mode 1)
    (setq eyebrowse-new-workspace t
          eyebrowse-wrap-around t))
#+END_SRC


* Projectile
:PROPERTIES:
:REPO:     https://github.com/bbatsov/projectile
:END:

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :after ripgrep
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :init
    (projectile-mode t)
    :config
    (setq projectile-project-search-path (my-project-paths)
          projectile-sort-order 'recently-active))
#+END_SRC

* Ripgrep
:PROPERTIES:
:REPO:     https://github.com/nlamirault/ripgrep.el
:END:

Projectile needs Ripgrep to enable ripgrep searches!
#+BEGIN_SRC emacs-lisp
  (use-package ripgrep)
#+END_SRC

* pdf-tools
:PROPERTIES:
:REPO:     https://github.com/politza/pdf-tools
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2020-11-11 Wed 13:33]
- State "TODO"       from              [2020-08-18 Tue 11:09]
:END:


#+BEGIN_SRC emacs-lisp :tangle no
  (use-package pdf-tools
    :hook
    (pdf-view-mode . (lambda () (display-line-numbers-mode -1)))
    :general
    (pdf-view-mode-map
     "M-w" 'pdf-view-kill-ring-save)
    :init
    (pdf-loader-install t)
    (setq-default pdf-view-display-size 'fit-page))
#+END_SRC

* TODO shift-line-up and down
:LOGBOOK:
- State "TODO"       from              [2020-08-16 Sun 13:27]
:END:

In a number of prog modes, it'd be useful to be able to move lines
up and down. Maybe even expressions up and down. M-<up>, for instance?

* Send window to next frame

I'd like to be able to move a window from one frame to the next. By
which I mean:
1. If the current frame has more than one window: close the current
   window. If the current frame only has one window, switch to the
   'previous buffer'
2. On the next (target) frame: open a new window. If the window is wide, open
   it to the right; otherwise open it on the bottom.
3. Open the buffer from the original closed window in the new buffer.

   #+BEGIN_SRC emacs-lisp
     (defun heartman/send-buffer-to-frame (arg)
       "Send the current buffer to another frame.

     ARG (positive or negative) specifies how many frames to send it.
     Focus follows the window."
       (let ((buffer (current-buffer))
             (window (selected-window)))
         (if (< 1 (length (window-list)))
             (delete-window)
           (previous-buffer)
           (unrecord-window-buffer window buffer))
         (other-frame arg)
         (select-window
          (car (last
                (window-list nil 'never (frame-first-window)))))
         (if (> (window-pixel-height) (window-pixel-width))
             (split-window-below-and-focus)
           (split-window-right-and-focus))
         (switch-to-buffer buffer)))
   #+END_SRC

* Make window fill {left,right,upper,lower} half of frame

I'd like to be able to send a window to a specified half of a frame.
Any other windows in the same frame should split the remaining space
evenly between them.

To solve this:

1. Delete other windows. We'll start with a fresh window covering the
   whole screen.
2. Split this window according to the directional argument.
3. Partition the other screen half into `frame-windows - 1` smaller windows.
4. Assign buffers to windows.

#+BEGIN_SRC emacs-lisp
  (defun heartman/split-windows (windows buffers-to-display)
    "Split the largest window among WINDOWS. Repeat til there are NUM-WINDOWS.

  Splits the window along it's longest axis (bottom or right)."
    (let ((next-buffer (car buffers-to-display))
          (remaining-buffers (cdr buffers-to-display)))
      (cl-flet ((split-window-f (window width height)
                                (let ((side (if (> height width)
                                                'below
                                              'right)))
                                  (split-window window nil side t)))

                (create-window-plist (w) (let* ((height (window-pixel-height w))
                                                (width (window-pixel-width w))
                                                (area (* height width)))
                                           `(window ,w height ,height width ,width area ,area))))
        (require 'seq)
        (if remaining-buffers
            (let* ((windows-list (mapcar #'create-window-plist windows))
                   (largest-window (if (<= 2 (length windows-list))
                                       (progn
                                         (seq-reduce (lambda (largest next)
                                                       (if (>= (plist-get next 'area) (plist-get largest 'area))
                                                           next
                                                         largest)) (cdr windows-list)
                                                         (car windows-list)))
                                     (car windows-list)))
                   (new-window (split-window-f
                                (plist-get largest-window 'window)
                                (plist-get largest-window 'width)
                                (plist-get largest-window 'height))))
              (save-selected-window
                (select-window new-window)
                (switch-to-buffer next-buffer))
              (heartman/split-windows (cons new-window windows) remaining-buffers)))
        (save-selected-window
          (select-window (car windows))
          (switch-to-buffer next-buffer)))))


  (defun heartman/send-window-to-frame-half (section)
    "Send the current window to the specified half of the screen.

  Valid values for `SECTION' are 'left, 'right, 'above and 'below."
    (let* ((windows (window-list))
           (other-windows (cdr windows))
           (other-buffers (mapcar #'window-buffer other-windows)))
      (delete-other-windows)
      (cl-flet ((flip (direction) (cond
                                   ((eq direction 'left) 'right)
                                   ((eq direction 'right) 'left)
                                   ((eq direction 'up) 'down)
                                   ((eq direction 'down) 'up))))
        (let ((new-main-window (selected-window))
              (window-to-partition (split-window nil nil (flip section))))
          (heartman/split-windows (list window-to-partition) other-buffers)))))


  (defun heartman/send-window (direction)
    "Send the current window to frame half."
    (lambda ()
      (interactive)
      (heartman/send-window-to-frame-half direction)))
#+END_SRC


* exwm
:PROPERTIES:
:REPO:     https://github.com/ch11ng/exwm
:WIKI:     [[https://github.com/ch11ng/exwm/wiki][GitHub wiki]]
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-04-09 Fri 08:02]
- State "TODO"       from              [2020-08-16 Sun 12:19]
:END:

I use EXWM as my window manager on NixOS, so let's get that set up.

This is based on a mix between my own setup and [[https://github.com/daedreth/UncleDavesEmacs][UncleDavesEmacs]]
setup.

The ivy-posframe workaround is taken from [[https://github.com/ch11ng/exwm/issues/550#issuecomment-590875069][this comment on a GitHub
issue]].

#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :after (hydra)
    :when use-exwm
    :custom
    (exwm-replace nil)
    (exwm-input-global-keys
     `(([?\s-r] . exwm-reset)
       ([?\s- ] . my-exwm-launcher)

       ;; buffer management
       ([?\s-n] . next-buffer)
       ([?\s-p] . previous-buffer)
       ([?\s-b] . switch-to-buffer)
       ([?\s-f] . find-file)
       ([?\s-q] . my-kill-current-buffer)
       ([?\s-d] . delete-window)
       ([?\s-j] . heartman/select-window)
       ([?\s-k] . heartman/delete-current-file)

       ;; window management
       ([\C-\s-left] . ,(heartman/send-window 'left))
       ([\C-\s-right] . ,(heartman/send-window 'right))
       ([\C-\s-up] . ,(heartman/send-window 'up))
       ([\C-\s-down] . ,(heartman/send-window 'down))


       ([?\s-g] . magit-status)
       ([?\s-G] . magit-status-dotfiles)

       ;; window navigation and management
       ([?\s-w] . hydra-window-movement/body)
       ([\s-up] . windmove-up)
       ([\s-down] . windmove-down)
       ([\s-right] . windmove-right)
       ([\s-left] . windmove-left)
       ([?\s-m] . my-maximize-or-undo-window)
       ([\s-next] . my-exwm-send-buffer-next-workspace)
       ([\s-prior] . my-exwm-send-buffer-previous-workspace)

       ;;tabs
       ([?\s-t ?t] . heartman/tab-other-frame)
       ([?\s-t right] . heartman/send-tab-to-next-frame)
       ([?\s-t left] . heartman/send-tab-to-previous-frame)
       ([?\s->] . tab-bar-switch-to-next-tab)
       ([?\s-<] . tab-bar-switch-to-prev-tab)
       ([?\s-,] . tab-bar-switch-to-recent-tab)
       ([?\s-t ?k] . tab-close)
       ([?\s-t ?n] . tab-bar-new-tab)
       ([?\s-t ?c] . tab-bar-duplicate-tab)
       ([?\s-t ?r] . tab-rename)

       ;; shell commands
       ([?\s-!] . shell-command)
       ([?\s-&] . async-shell-command)

       ;; workspace navigation and management
       ([\s-tab] . my-previous-window)
       ([?\s-l] . my-exwm-next-workspace-by-index)
       ([?\s-h] . my-exwm-previous-workspace-by-index)

       ([?\s-a ?m] . notmuch)
       ([?\s-a ?f] . elfeed)
       ([?\s-a ?r] . ranger)
       ([?\s-a ?b] . browse-url)
       ([?\s-o ?a] . org-agenda)
       ([?\s-o ?c] . org-capture)
       ([?\s-o ?r] . helm-org-rifle-agenda-files)
       ([?\s-a ?l] . lexic-search)
       ([?\s-a ?g] . heartman/open-google-meet-link-in-chromium)
       ([?\s-e ?b] . bluetooth-list-devices)

       ([\f9] . multi-term-dedicated-toggle)

       ([?\s-u] . universal-argument)
       ([?\M-u] . universal-argument)

       ;; window splitting and management
       ([?\s-|] . split-window-right-and-focus)
       ([?\s-_] . split-window-below-and-focus)

       ;; workspace / window numerical
       ,@(mapcar (lambda (i)
                   `(,(kbd (format "s-C-%d" i)) .
                     (lambda ()
                       (interactive)
                       (exwm-workspace-switch-create ,i))))
                 (number-sequence 0 9))
       ,@(mapcar (lambda (i)
                   `(,(kbd (format "s-%d" i)) .
                     (lambda ()
                       (interactive)
                       (winum-select-window-by-number ,i))))
                 (number-sequence 0 9))))

    (exwm-input-simulation-keys
     '(
       ;; movement
       ([?\M-b] . [C-left])
       ([?\M-f] . [C-right])
       ([?\C-p] . [up])
       ([?\C-n] . [down])
       ([?\C-a] . [home])
       ([?\M-n] . [C-n])
       ([?\M-p] . [C-S-p])
       ([?\M-a] . [C-a])
       ([?\C-e] . [end])
       ([?\C-k] . [S-end C-x])
       ;; cut and paste
       ([?\M-k] . [C-x])
       ([?\M-w] . [C-c])
       ([?\C-y] . [C-v])
       ;; search
       ([?\C-s] . [C-f])
       ;; terminal escape
       ([?\C-c ?\C-c] . [C-c])))
    :config
    (when (not (server-running-p))
      (server-start))
    (setq exwm-workspace-number 3
          exwm-workspace-show-all-buffers t
          exwm-layout-show-all-buffers t)

    (defun my-exwm-launcher (command)
      "A super-simple launcher"
      (interactive (list (read-shell-command "Launch application: ")))
      (start-process-shell-command command nil command))

    (defvar my-exwm-toggle-workspace 0
      "Previously selected workspace. Used with the below function.")
    (defun my-exwm-previous-workspace ()
      "Switch to previous active workspace."
      (interactive)
      (exwm-workspace-switch my-exwm-toggle-workspace))
    (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
      (setq my-exwm-toggle-workspace exwm-workspace-current-index))
    ;; (exwm-input-set-key (kbd "<s-tab>") #'my-exwm-previous-workspace)

    (defun my-exwm-switch-workspace (operator)
      (exwm-workspace-switch
       (mod (funcall operator exwm-workspace-current-index 1) (length exwm-workspace--list))))

    (defun my-exwm-next-workspace-by-index ()
      "Switch to the next workspace."
      (interactive)
      (my-exwm-switch-workspace '+))

    (defun my-exwm-previous-workspace-by-index ()
      "Switch to the previous workspace."
      (interactive)
      (my-exwm-switch-workspace '-))

    (defun my-exwm-send-buffer-next-workspace ()
      "Send the current buffer to the next workspace."
      (interactive)
      (heartman/send-buffer-to-frame -1))

    (defun my-exwm-send-buffer-previous-workspace ()
      "Send the current buffer to the next workspace."
      (interactive)
      (heartman/send-buffer-to-frame 1))

    (define-key key-translation-map [?\s-s] (kbd "C-x C-s"))

    (add-hook 'exwm-update-title-hook (lambda () (exwm-workspace-rename-buffer exwm-title)))

    ;; configure RandR support
    (require 'exwm-randr)

    (defun heartman/auto-set-exwm-monitors ()
      "Try to automatically detect and set EXWM monitors based on xrandr output."
      (interactive)
      (let* ((output (shell-command-to-string
                      "xrandr | grep \" connected\" | awk '{ print $1 }'"))
             (monitors-list (split-string output))
             (monitors
              (flatten-tree (seq-map-indexed (lambda (n x) (list x n)) monitors-list))))
        (if (and (eq (length monitors) (length exwm-randr-workspace-monitor-plist))
                 (seq-every-p (lambda (x)
                                (seq-contains exwm-randr-workspace-monitor-plist x)) monitors))
            (message "No change in monitor setup. Not doing anything.")
          (setq exwm-randr-workspace-monitor-plist monitors))))

    (defun heartman/exwm-randr-refresh ()
      "Auto-detects monitors and tries to refresh exwm-randr"
      (interactive)
      (heartman/auto-set-exwm-monitors)
      (exwm-randr-refresh))

    (heartman/auto-set-exwm-monitors)
    (exwm-randr-enable)


    ;; this little bit will make sure that XF86 keys work in exwm buffers as well
    (dolist (k '(XF86AudioLowerVolume
                 XF86AudioRaiseVolume
                 XF86PowerOff
                 XF86AudioMute
                 XF86AudioPlay
                 XF86AudioStop
                 XF86AudioPrev
                 XF86AudioNext
                 XF86ScreenSaver
                 XF68Back
                 XF86Forward
                 Scroll_Lock
                 print))
      (cl-pushnew k exwm-input-prefix-keys))


    ;; force set frame-position on every posframe display
    (advice-add 'posframe--set-frame-position :before
                (lambda (&rest args)
                  (setq-local posframe--last-posframe-pixel-position nil)))
    :hook
    (exwm-mode . (lambda ()
                   (display-line-numbers-mode -1)))
    (exwm-randr-screen-change . (lambda ()
                                  (let ((proc (start-process-shell-command
                                               "autorandr" nil
                                               "autorandr -c"))))
                                  )))
#+END_SRC

** desktop-environment
:PROPERTIES:
:REPO:     https://github.com/DamienCassou/desktop-environment
:END:

Desktop-environment offers mappings of special keys to
OS-functions.

The package depends on the following system packages being
available:
- volume :: [[https://github.com/cdemoulins/pamixer][pamixer]]
- brightness :: [[https://github.com/Hummer12007/brightnessctl][brightnessctl]]
- screenshot :: [[https://tracker.debian.org/pkg/scrot][scrot]]
- screen lock :: [[https://tools.suckless.org/slock/][slock]]
- keyboard backlight :: [[https://upower.freedesktop.org/][upower]]
- wifi and bluetooth :: [[https://linrunner.de/en/tlp/tlp.html][TLP]]
- music :: [[https://github.com/altdesktop/playerctl][playerctl]]


#+BEGIN_SRC emacs-lisp
  (use-package desktop-environment
    :after (exwm)
    :when use-exwm
    :demand t
    :custom
    (desktop-environment-volume-get-command "pamixer --get-volume-human")
    (desktop-environment-volume-get-regexp "\\(muted\\|[0-9]+%\\)")
    (desktop-environment-volume-toggle-command "pamixer --toggle-mute")
    (desktop-environment-volume-normal-increment "5")
    (desktop-environment-volume-normal-decrement "5")
    (desktop-environment-screenlock-command "i3lock --nofork -c 000000")
    (desktop-environment-screenshot-directory "/tmp")
    :config
    (setf (alist-get (elt (kbd "s-l") 0) desktop-environment-mode-map nil t) nil)
    (desktop-environment-mode)

    (defun heartman/desktop-environment-step-volume (arg)
      "Increment or decrement the volume. ARG is either `increment' or
  `decrement'."
      (let* ((args (cond
                    ((eq arg 'increment)
                     (format "-i %s" desktop-environment-volume-normal-increment))
                    ((eq arg 'decrement)
                     (format "-d %s" desktop-environment-volume-normal-decrement))
                    (t (user-error (format "Received invalid argument: %s" arg)))))
             (cmd (format "pamixer %s" args)))
        (desktop-environment--shell-command-to-string cmd)
        (message "New volume value: %s" (desktop-environment-volume-get))))

    ;; redefine these to work with pamixer
    (defun desktop-environment-volume-increment ()
      "Increment volume by `desktop-environment-volume-normal-increment'."
      (interactive)
      (heartman/desktop-environment-step-volume 'increment))

    (defun desktop-environment-volume-decrement ()
      "Decrement volume by `desktop-environment-volume-normal-decrement'."
      (interactive)
      (heartman/desktop-environment-step-volume 'decrement))

    (defun heartman/pamixer-get-mute-status ()
      "Get whether the volume is currently muted or not. Also report the actual volume level."
      (let ((mute-status
             (if (string-match-p "true" (shell-command-to-string "pamixer --get-mute"))
                 "muted"
               "unmuted")))
        (message "Volume: %s%% (%s)" (s-trim (shell-command-to-string "pamixer --get-volume")) mute-status)))

    (advice-add #'desktop-environment-toggle-mute
                :after #'heartman/pamixer-get-mute-status)

    :general
    (general-def
      desktop-environment-mode-map
      "s-<f1>" 'desktop-environment-lock-screen))
#+END_SRC

** matching macOS bindings                                            :macos:

Because the bindings for EXWM using the super key are very
accessible, we can bind the equivalent key presses for macOS.
Because Alt+characters tend to give other characters on macOS, the
list will look a bit different.
#+BEGIN_SRC emacs-lisp
  (when on-macos
    (general-def
      "π" 'previous-buffer
      "∫" 'switch-to-buffer
      "ç" 'balance-windows
      "œ" 'my-kill-current-buffer
      "Œ" (lambda () (interactive)
            (save-buffer)
            (my-kill-current-buffer))
      "∂" 'delete-window
      "ƒ" 'find-file
      "ß" (general-key "C-x C-s")
      "©" 'magit-status
      "µ" 'my-maximize-or-undo-window
      "∑" 'hydra-window-movement/body
      "»" 'split-window-right-and-focus
      "—" 'split-window-below-and-focus))
#+END_SRC

* TODO multiterm
:PROPERTIES:
:REPO:     https://github.com/manateelazycat/multi-term
:WIKI:     [[https://www.emacswiki.org/emacs/MultiTerm][EmacsWiki]]
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-20 Thu 21:26] \\
  Make Fish prompt work properly. At the moment, it eats whatever you
  type into the window, which isn't ideal. However, this isn't only for
  multiterm, but also applies to ansi-term.
:END:

#+BEGIN_SRC emacs-lisp
  (use-package multi-term
    :bind
    ("<f9>" . multi-term-dedicated-toggle)
    :config
    (setq multi-term-dedicated-select-after-open-p t
          multi-term-dedicated-close-back-to-open-buffer-p t))
#+END_SRC


* TODO [#C] Aweshell
:PROPERTIES:
:REPO:     https://github.com/manateelazycat/aweshell
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-13 Thu 18:50]
:END:

TODO: figure out why this messes with my frame setup. For whatever
reason, this causes frames to be slightly misaligned with EXWM on
NixOS. Unsure why. I'll leave it out for now as I also had several
other issues with getting it to work.

Aweshell was created by the same person that created multi-term.
It's extends eshell with a number of features.

#+BEGIN_SRC emacs-lisp :tangle no
  (require 'aweshell)
  (general-def
    "<f9>" 'aweshell-toggle)
#+END_SRC




** Eshell-autojump
:PROPERTIES:
:REPO:     https://github.com/coldnew/eshell-autojump
:END:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package eshell-autojump
    :demand t)
#+END_SRC

* TODO [#C] Bibtex
:LOGBOOK:
- State "TODO"       from              [2020-08-14 Fri 08:38]
:END:

Get BibTex to work properly. [[http://www.jonathanleroux.org/bibtex-mode.html][Here's the manual]]. See what you can
find.

* TODO Mode line
:LOGBOOK:
- State "TODO"       from              [2021-05-06 Thu 10:08] \\
  Sort this out. You might want to create your own customization.
:END:

We can configure the mode line to only show what we want. I find
that the default displ/ays far more information than I know what to
do with, so let's trim it down a bit and show only what's necessary.

#+BEGIN_SRC emacs-lisp
  (display-time-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package doom-modeline
    :after markdown-mode
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-unicode-fallback t)
    (doom-modeline-enable-word-count t)
    (doom-modeline-continuous-word-count-modes nil)
    (doom-modeline-checker-simple-format nil)
    (doom-modeline-buffer-modification-icon nil)
    (doom-modeline-buffer-state-icon nil)
    (doom-modeline-buffer-encoding nil))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package smart-mode-line
    :init
    (smart-mode-line-enable))
#+END_SRC


** TODO Custom mode line
:LOGBOOK:
- State "TODO"       from              [2021-05-14 Fri 16:15] \\
  Finish this
:END:

This is my attempt at customizing my mode line from the ground up.

#+BEGIN_SRC emacs-lisp
  (defvar heartman/mode-line-buffer-max-length 30
    "The maximum number of charaacters in a buffer name. Any more characters will cause a truncation.")

  (defvar heartman/mode-line-flycheck-separator "/"
    "The separator to use between flycheck notifications.")

  (defun heartman/mode-line-format-buffer-name (name)
    "Format the buffer name for display"
    (let ((new-name (if (and (stringp exwm-class-name)
                             (string= "Firefox" exwm-class-name))
                        (format "🦊 %s" (string-remove-suffix "— Mozilla Firefox" name))
                      name)))
      (truncate-string-to-width
       new-name
       heartman/mode-line-buffer-max-length
       nil nil t)))

  (defvar heartman/mode-line-icons '(;; VCS
                                     (git-compare . ?\xf0ac)            ; 
                                     (git-merge . ?\xf023)              ; 
                                     (arrow-down . ?\xf03f)             ; 
                                     (alert . ?\xf02d)                  ; 
                                     (git-branch . ?\xf020)             ; 

                                     ;; Checker
                                     (do_not_disturb_alt . ?\xe611)     ; 
                                     (check . ?\xe5ca)                  ; 
                                     (access_time . ?\xe192)            ; 
                                     (sim_card_alert . ?\xe624)         ; 
                                     (pause . ?\xe034)                  ; 
                                     (priority_high . ?\xe645)          ; 

                                     ;; Minor modes
                                     (gear . ?\xf02f)                   ; 

                                     ;; Persp
                                     (folder . ?\xe2c7)                 ; 

                                     ;; Preview
                                     (pageview . ?\xe8a0)               ; 

                                     ;; REPL
                                     (dollar-sign . ?\xf155)            ; 

                                     ;; LSP
                                     (rocket . ?\xf135)                 ; 

                                     ;; GitHub
                                     (github . ?\xf09b)                 ; 

                                     ;; Debug
                                     (bug . ?\xf188)                    ; 

                                     ;; Mail
                                     (email . ?\xe0be)                  ; 

                                     ;; IRC
                                     (message . ?\xe0c9)                ; 

                                     ;; Battery
                                     (battery-charging . ?\xe939)       ; 
                                     (battery-empty . ?\xf244)          ; 
                                     (battery-full . ?\xf240)           ; 
                                     (battery-half . ?\xf242)           ; 
                                     (battery-quarter . ?\xf243)        ; 
                                     (battery-three-quarters . ?\xf241) ; 
                                     )
    "Icons for mode line (stolen from doom-modeline). Depending on
  your font, they may display differently in the comments.")


  (setq-default mode-line-format
                (list
                 "%e"

                 '(:eval
                   (unless (eq major-mode 'exwm-mode)
                     evil-mode-line-tag))

                 '(:eval (let ((remote-info
                                (file-remote-p (or buffer-file-name default-directory ""))))
                           (when remote-info
                             (propertize
                              remote-info
                              'face 'font-lock-function-name-face))))

                 '(:eval (list
                          (heartman/mode-line-format-buffer-name
                           (propertize  "%b"
                                        'face 'font-lock-type-face
                                        'help-echo (buffer-file-name)))
                          (if (buffer-modified-p)
                              (propertize "*"
                                          'face 'font-lock-negation-char-face)
                            " ")
                          (when (and buffer-read-only (not exwm-class-name))
                            "👁")
                          " "))

                 '(:eval (let ((project (projectile-project-name)))
                           (unless (string= "-" project)
                             (propertize (format "%s " project)
                                         'face 'font-lock-constant-face))))

                 '(:eval (when-let (vc vc-mode)
                           (list
                            (format "%c " ?\xf020)
                            (propertize (substring vc 5)
                                        'face 'font-lock-doc-face)
                            " ")))


                 mode-line-modes

                 mode-line-position

                 '(:eval
                   (when flycheck-mode
                     (cl-flet ((fmt (count face)
                                    (if count
                                        (propertize (format "%d" count)
                                                    'face face)
                                      "0")))
                       (let-alist (flycheck-count-errors flycheck-current-errors)
                         (list
                          (if (or .error .warning .info)
                              (propertize "!"
                                          'face 'font-lock-negation-char-face)
                            " ")
                          (fmt .error compilation-error-face)
                          heartman/mode-line-flycheck-separator
                          (fmt .warning compilation-warning-face)
                          heartman/mode-line-flycheck-separator
                          (fmt .info compilation-info-face))))))


                 " "

                 '(:eval
                   (when debug-on-error
                     (propertize
                      (format "%c" ?\xf188)
                      'face compilation-error-face)))

                 " "

                 mode-line-misc-info))

#+END_SRC

* C#

** csharp-mode
:PROPERTIES:
:REPO:     https://github.com/josteink/csharp-mode
:END:

#+BEGIN_SRC emacs-lisp
  (use-package csharp-mode
    :mode ("\\.csproj\\'" . xml-mode)
    :after lsp-mode
    :general
    (csharp-mode-map
     :start-maps t
     my-format-buffer 'lsp-format-buffer)
    :hook
    (csharp-mode . lsp))
#+END_SRC


** TODO omnisharp-emacs
:PROPERTIES:
:REPO:     https://github.com/OmniSharp/omnisharp-emacs
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-14 Fri 14:06]
:END:

TODO: find out if you /actually/ need this. I suspect not with lsp
mode.

For C#, the language server is a separate package, so we must
install it independently.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package omnisharp
    :after company
    :config
    (add-to-list 'company-backends 'company-omnisharp))
#+END_SRC


Omnisharp-mode decides which server version to use based on what a
certain variable is set to. Because this can get outdated, here's a
function you can use to set the variable to the most recent
version:

#+BEGIN_SRC emacs-lisp :tangle no
  (defun latest-version-from-github-json-api-response (input)
    "Extract the tag name from a GitHub API response to the releases endpoint."
    (require 'json)
    (require 'subr-x)
    (let* ((json-object-type 'hash-table)
           (json-array-type 'list)
           (json-key-type 'string))
      (string-remove-prefix "v"
                            (gethash "tag_name"
                                     (json-read-from-string input)))))


  (defun get-latest-omnisharp-release ()
    (shell-command-to-string "curl https://api.github.com/repos/omnisharp/omnisharp-roslyn/releases/latest 2>/dev/null"))

  (defun set-latest-omnisharp-version ()
    "Fetch release data from GitHub and set the expected server
  version to the most recent release."
    (interactive)
    (message "Fetching data about the latest release ...")
    (let* ((output (get-latest-omnisharp-release))
           (version (latest-version-from-github-json-api-response output)))
      (message "The most recent version is v%s." version)
      (setq omnisharp-expected-server-version version)))
#+END_SRC

* F#
:PROPERTIES:
:REPO:     https://github.com/fsharp/emacs-fsharp-mode
:END:

#+BEGIN_SRC emacs-lisp
  (use-package fsharp-mode
    :after lsp
    :mode ("\\.fsproj\\'" . xml-mode)
    :hook
    (fsharp-mode . lsp))
#+END_SRC


* Transpose-frame
:PROPERTIES:
:WIKI:     [[https://www.emacswiki.org/emacs/TransposeFrame][EmacsWiki]]
:END:

#+BEGIN_SRC emacs-lisp
  (use-package transpose-frame)
#+END_SRC


* Aggressive indent
:PROPERTIES:
:REPO:     https://github.com/Malabarba/aggressive-indent-mode
:END:

This seems to cause some serious slowdown issues in JS, at least.
For now, I'll enable it for Lisp, but leave it off otherwise. Most
languages I work in have a formatter anyway.


#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :hook
    (emacs-lisp-mode . aggressive-indent-mode))
#+END_SRC

* Timestamps

Having a simple way to insert the current timestamp in an
ISO-friendly manner can be quite useful.
#+BEGIN_SRC emacs-lisp
  (defun insert-iso-timestamp ()
    (interactive)
    (insert (format-time-string "%FT%T%:z")))

  (my-app-def
    "i t" 'insert-iso-timestamp)
#+END_SRC

* TODO JavaScript (rjsx-mode)
:PROPERTIES:
:REPO:     https://github.com/felipeochoa/rjsx-mode/
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-16 Sun 19:53]
:END:

Consider using [[https://github.com/magnars/js2-refactor.el][js2-refactor]] if rjsx (and lsp) isn't enough.

rjsx-mode extends js2-mode to add support for JSX.
#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :after
    (prettier lsp-mode)
    :hook
    (rjsx-mode . prettier-mode)
    (rjsx-mode . lsp-mode)
    :config
    (setq js2-strict-missing-semi-warning nil))
#+END_SRC

* JavaScript mode

#+BEGIN_SRC emacs-lisp
  (use-package js
    :mode ("\\.es\\'" . js-mode))
#+END_SRC

* TODO Prettier
:PROPERTIES:
:REPO:     https://github.com/prettier/prettier-emacs
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-20 Thu 21:29] \\
  Make sure this is set up in the modes where it's expected to work.
:END:

For indenting JS, CSS, HTML (maybe markdown?), let's use prettier!
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package prettier-js
    :hook
    (prettier-js . my-prettier-hook)
    :config
    (defun my-prettier-hook ()
      (general-def
        :keymaps 'local
        my-format-buffer 'prettier-js)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package prettier
    :hook
    (prettier-mode . my-prettier-hook)
    :config
    (defun my-prettier-hook ()
      (general-def
        :keymaps 'local
        my-format-buffer 'prettier-prettify)))
#+END_SRC


* Typescript

** Tide

#+BEGIN_SRC emacs-lisp
  (use-package tide
    :mode ("\\.tsx?\\'" . typescript-mode)
    :after (typescript-mode company flycheck prettier)
    :hook ((typescript-mode . tide-setup)
           (typescript-mode . tide-hl-identifier-mode)
           (typescript-mode . lsp)
           (typescript-mode . prettier-mode)
           (typescript-mode . emmet-mode)
           (before-save . 'prettier-prettify)))
#+END_SRC



* TODO desktop (saving emacs sessions)
:LOGBOOK:
- State "TODO"       from              [2020-08-20 Thu 21:29] \\
  Find out why this messes with EXWM and frame alignment.
:END:

Apparently, the built-in desktop library can save your sessions and
restore them when you start back up. Let's try it out and see what
happens.

#+BEGIN_SRC emacs-lisp
  (use-package desktop
    :when on-macos
    :init
    (desktop-save-mode 1)
    (setq desktop-restore-eager 10))

#+END_SRC

* TODO Web-mode
:PROPERTIES:
:WEBSITE:  [[http://web-mode.org/][web-mode.org]]
:END:
:LOGBOOK:
- State "TODO"       from              [2020-11-20 Fri 13:31] \\
  Reconsider whether you want to reactivate this.
:END:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package web-mode
    :mode "\\.html\\'"
    :after (prettier smartparens hydra)
    :hook
    (web-mode . prettier-mode)
    (web-mode . my-web-mode-hook)
    :init
    (defun my-web-mode-hook ()
      (setq web-mode-enable-auto-pairing nil))
    :config
    (setq web-mode-enable-css-colorization t
          web-mode-enable-current-element-highlight t
          web-mode-enable-current-column-highlight t)
    (defun sp-web-mode-is-code-context (id action context)
      (and (eq action 'insert)
           (not (or (get-text-property (point) 'part-side)
                    (get-text-property (point) 'block-side)))))
    (sp-local-pair 'web-mode "<" nil :when '(sp-web-mode-is-code-context))
    (defhydra hydra-web-mode-base ()
      ("C-z a" hydra-web-mode-attributes/body :color blue)
      ("C-z e" hydra-web-mode-element/body :color blue)
      ("C-z t" hydra-web-mode-tag/body :color blue)
      ("C-q" nil))

    (defhydra hydra-web-mode-launcher (web-mode-map "C-c C-c" :color blue)
      ("a" hydra-web-mode-attributes/body)
      ("e" hydra-web-mode-element/body)
      ("t" hydra-web-mode-tag/body))

    (defhydra hydra-web-mode-element (:inherit (hydra-web-mode-base/heads) :foreign-keys run)
      "Element mode"
      ("C-/" web-mode-element-close)
      ("C-a" web-mode-element-content-select)
      ("C-b" web-mode-element-beginning)
      ("C-c" web-mode-element-clone)
      ("C-d" web-mode-element-child)
      ("C-e" web-mode-element-end)
      ("C-f" web-mode-element-children-fold-or-unfold)
      ("C-i" web-mode-element-insert)
      ("C-k" web-mode-element-kill)
      ("C-m" web-mode-element-mute-blanks)
      ("C-n" web-mode-element-next)
      ("C-p" web-mode-element-previous)
      ("C-r" web-mode-element-rename)
      ("C-s" web-mode-element-select)
      ("C-t" web-mode-element-transpose)
      ("C-u" web-mode-element-parent)
      ("C-v" web-mode-element-vanish)
      ("C-w" web-mode-element-wrap)
      )
    (hydra-set-property 'hydra-web-mode-element :verbosity 1)

    (defhydra hydra-web-mode-tag (:inherit (hydra-web-mode-base/heads) :foreign-keys run)
      "Tag mode"
      ("C-a" web-mode-tag-attributes-sort)
      ("C-b" web-mode-tag-beginning)
      ("C-e" web-mode-tag-end)
      ("C-m" web-mode-tag-match)
      ("C-n" web-mode-tag-next)
      ("C-p" web-mode-tag-previous)
      ("C-s" web-mode-tag-select)
      )
    (hydra-set-property 'hydra-web-mode-tag :verbosity 1)

    (defhydra hydra-web-mode-attributes (:inherit (hydra-web-mode-base/heads) :foreign-keys run)
      "Attribute mode"
      ("C-b" web-mode-attribute-beginning)
      ("C-e" web-mode-attribute-end)
      ("C-i" web-mode-attribute-insert)
      ("C-k" web-mode-attribute-kill)
      ("C-n" web-mode-attribute-next)
      ("C-p" web-mode-attribute-previous)
      ("C-s" web-mode-attribute-select)
      ("C-t" web-mode-attribute-transpose)
      )
    (hydra-set-property 'hydra-web-mode-attributes :verbosity 1))
#+END_SRC

* Bufler
:PROPERTIES:
:REPO:     https://github.com/alphapapa/bufler.el
:END:

Bufler is a buffer management tool that groups your buffers into
projects or other groups for easier navigation.

#+BEGIN_SRC emacs-lisp
  (use-package bufler
    :general
    ("C-x B" 'bufler-switch-buffer
     [remap list-buffers] 'bufler)
    :config
    (bufler-mode))
#+END_SRC

* TODO Ranger
:PROPERTIES:
:REPO:     https://github.com/ralesi/ranger.el
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-21 Fri 09:35] \\
  I have some issues with ranger disabling the cursor. This can be
  reverted by setting ~cursor-type~ to ~t~, but it is annoying.

  I'm not the only one, though. [[https://github.com/ralesi/ranger.el/issues/213][This GitHub issue]] describes the same thing.
- State "TODO"       from              [2020-08-20 Thu 14:40]
:END:

Ranger is a file browser that builds on dired, offering some more
functionality.

#+BEGIN_SRC emacs-lisp
  (use-package ranger
    :general
    (my-app-def
      "R" 'ranger)
    :config
    (setq ranger-show-hidden t
          ranger-parent-depth 1
          ranger-modify-header nil
          ranger-preview-file t
          ranger-show-literal nil
          ranger-hide-cursor nil))
#+END_SRC

* Fish shell
:PROPERTIES:
:REPO:     https://github.com/wwwjfy/emacs-fish
:END:

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode "\\.fish\\'")
#+END_SRC

* yaml mode
:PROPERTIES:
:REPO:     https://github.com/yaml/yaml-mode
:END:

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :hook (yaml-mode . lsp))
#+END_SRC

* TODO indent-tools
:PROPERTIES:
:REPO:     https://gitlab.com/emacs-stuff/indent-tools/
:END:
:LOGBOOK:
- State "TODO"       from              [2020-08-24 Mon 11:58] \\
  Fix some of the bindings. For undo, for instance, it relies on
  undo-tree, which I don't use. Instead, make undo (the regular emacs
  one) available from the hydra. Also, parent-child-movement seems a bit
  wonky in yaml.
:END:

indent-tools provides a hydra that offers a number of ways to
interact with indentation-based languages such as YAML and Python.

#+BEGIN_SRC emacs-lisp
  (use-package indent-tools
    :general
    ("C-c i" 'indent-tools-hydra/body))
#+END_SRC

* term-mode

To make fish work properly in ansi-term, this little configuration
is necessary:
#+BEGIN_SRC emacs-lisp
  (add-hook 'term-mode-hook 'toggle-truncate-lines)
#+END_SRC

* heart-mode

We can define a personalized minor mode to store keymaps in. This
may be an efficient way to make sure that keymaps are always
relevant. This is based on [[https://nullprogram.com/blog/2013/02/06/][this blog post (by Skeeto)]].
#+Begin_src emacs-lisp
  (define-minor-mode heart-mode
    "A minor mode for extra key mappings"
    :global t
    :keymap (make-sparse-keymap))
  (heart-mode)
#+END_SRC

* Geiser / Scheme
:PROPERTIES:
:WEBSITE:  [[https://www.nongnu.org/geiser/][nongnu.org/geiser]]
:END:

Based on [[https://ebzzry.io/en/emacs-scheme/][this blog post]], I'm experimenting with using [[https://www.nongnu.org/geiser/][Geiser]] for
Scheme mode.
#+BEGIN_SRC emacs-lisp
  (use-package geiser
    :config
    (setq geiser-active-implementations '(mit))
    (defun geiser-save ()
      "Invoke in the REPL buffer to force saving of the history to
  the disk file, which is found in ~/.geiser_history.mit, by
  default. It is useful if you want to save your REPL session,
  immediately."
      (interactive)
      (geiser-repl--write-input-ring)))
#+END_SRC

* Docker

** Dockerfile-mode
:PROPERTIES:
:REPO:     https://github.com/spotify/dockerfile-mode
:END:

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode
    :config
    (put 'dockerfile-image-name 'safe-local-variable #'stringp))
#+END_SRC


** TODO docker.el
:PROPERTIES:
:REPO:     https://github.com/Silex/docker.el
:END:
:LOGBOOK:
- State "TODO"       from              [2020-09-11 Fri 14:03] \\
  Test this out.
:END:

#+BEGIN_SRC emacs-lisp
  (use-package docker
    :general
    (my-app-def
      "D" 'docker))
#+END_SRC


* Whole line or region
:PROPERTIES:
:REPO:     https://github.com/purcell/whole-line-or-region
:END:

To make certain actions (cut, copy, paste) work on whole lines of
there is no region, I'll rely on purcell's package:
#+BEGIN_SRC emacs-lisp
  (use-package whole-line-or-region
    :config
    (whole-line-or-region-global-mode)

    (defun heartman/comment-whole-line-or-region (prefix)
      "Override comment-whole-line-or-region.

  The original function doesn't work well with empty lines, so let's change create a wrapper."
      (interactive "*p")
      (if (heartman/current-line-empty-p)
          (funcall-interactively 'comment-dwim prefix)
        (funcall-interactively 'whole-line-or-region-comment-dwim-2 prefix)))

    :general
    ('whole-line-or-region-local-mode-map
     "M-;" 'heartman/comment-whole-line-or-region))
#+END_SRC

* ctrlxo
:PROPERTIES:
:REPO:     https://github.com/muffinmad/emacs-ctrlxo
:END:
:LOGBOOK:
- State "TODO"       from              [2020-09-25 Fri 13:04] \\
  Check whether the [[https://github.com/melpa/melpa/pull/7150][pull request to MELPA]] has been merged yet.
:END:

Based on a [[https://www.reddit.com/r/emacs/comments/ixnes0/how_to_select_last_active_window_and_cycle/][question I posted on Reddit about cycling windows in
order of most recently used]], user [[https://www.reddit.com/user/fzmad/][fzmad]] created a package to do just
this.

As of [2020-09-23 Wed 15:36], the package is only available on
GitHub and not in any of the package archives, so I've taken the
liberty of simply copying and pasting the code below.

As of [2021-01-05 Tue], the package is available on Melpa, so now we
can simplify the use of it (plus get all the upgrades!).

#+BEGIN_SRC emacs-lisp
  (use-package ctrlxo
    :general
    ("C-x o" 'ctrlxo
     "s-<tab>" 'ctrlxo))
#+END_SRC

* Python
:PROPERTIES:
:REPO:     https://github.com/Microsoft/python-language-server
:WEBSITE:  [[https://emacs-lsp.github.io/lsp-python-ms/][website]]
:END:

We'll set up Python to use the MS language server:
#+BEGIN_SRC emacs-lisp
  (use-package lsp-python-ms
    :init (setq lsp-python-ms-auto-install-server t)
    :hook (python-mode . lsp))
#+END_SRC

* TODO region-to-async-shell-command
:LOGBOOK:
- State "TODO"       from              [2021-01-05 Tue 14:24] \\
  This doesn't work with a prefix-argument. Gives the error:
  ~shell-command--shell-command-with-editor-mode: Wrong type argument: stringp, (4)~
:END:

Sometimes it's handy to be able to send the selection to a shell and
evaluate this. Emacs doesn't have an inbuilt easy way to do this
(outside of org mode src blocks), so let's write a function that
does just that.

#+BEGIN_SRC emacs-lisp
  (defun my-async-shell-command (prefix)
    "Like `async-shell-command', but use region as COMMAND if it is active.

  If the region is active and `PREFIX' is nil, evaluate the region
  as COMMAND. Otherwise, relegate to `async-shell-command' as per
  usual."
    (interactive "P")
    (if (and (not prefix) (use-region-p))
        (async-shell-command
         (buffer-substring (region-beginning) (region-end)))
      (call-interactively 'async-shell-command)))

  (general-def
    [remap async-shell-command] 'my-async-shell-command)
#+END_SRC

* ligature.el
:PROPERTIES:
:REPO:     https://github.com/mickeynp/ligature.el
:END:

#+BEGIN_SRC emacs-lisp
  (use-package ligature
    :when native-comp
    :straight `(ligature :type git
                         :host github
                         :repo "mickeynp/ligature.el")
    :config
    ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable traditional ligature support in eww-mode, if the
    ;; `variable-pitch' face supports it
    (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
    ;; Enable all Cascadia Code ligatures in programming modes
    (ligature-set-ligatures '(prog-mode text-mode)
                            '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                              ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                              "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                              "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                              "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                              "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                              "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                              "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                              ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                              "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                              "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                              "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                              "\\\\" "://"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+END_SRC

* macrostep
:PROPERTIES:
:REPO:     https://github.com/joddie/macrostep
:END:

Macrostep is helpful for expanding (and thus working on) macros in
elisp.

#+BEGIN_SRC emacs-lisp
  (let ((expand "C-c C-e"))
    (use-package macrostep
      :general
      (emacs-lisp-mode-map
       :start-maps t
       expand 'macrostep-expand)
      (lisp-interaction-mode-map
       :start-maps t
       expand 'macrostep-expand)))
#+END_SRC

* Evil mode
:PROPERTIES:
:REPO:     https://github.com/emacs-evil/evil
:WEBSITE:  [[https://evil.readthedocs.io/en/latest/overview.html][Read the docs]]
:END:


So I finally caved. I might want to try out Evil mode for a bit, but
not for all buffers!

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init (evil-mode 1)
    (defun my-evil-insert-line-above (count)
      "Insert one or more lines above the current line without changing state or position.

      Based on spacemacs/evil-insert-line-above (https://github.com/syl20bnr/spacemacs/blob/61ff12cbfc1daf39a63d6597982c6f7b6c4db7a4/layers/%2Bspacemacs/spacemacs-defaults/funcs.el#L37)"
      (interactive "p")
      (let ((at-column-0 (= 0 (current-column))))
        (dotimes (_ count)
          (save-excursion (evil-insert-newline-above)))
        (when at-column-0
          (forward-line count))))

    (defun my-evil-insert-line-below (count)
      "Insert one or more lines below the current line without changing state or position.

      Based on spacemacs/evil-insert-line-below (https://github.com/syl20bnr/spacemacs/blob/61ff12cbfc1daf39a63d6597982c6f7b6c4db7a4/layers/%2Bspacemacs/spacemacs-defaults/funcs.el#L43)"
      (interactive "p")
      (dotimes (_ count) (save-excursion (evil-insert-newline-below))))
    :custom
    (evil-respect-visual-line-mode nil)
    (evil-want-Y-yank-to-eol t)
    (evil-symbol-word-search t)
    (evil-undo-system (if (fboundp 'undo-redo) 'undo-redo nil))

    :config
    (defmacro define-and-bind-text-object (name key start-regex end-regex)
      (let ((inner-name (make-symbol (format "evil-i-%s" name)))
            (outer-name (make-symbol (format "evil-a-%s" name))))
        `(progn
           (evil-define-text-object ,inner-name
             (count &optional beg end type)
             (evil-select-paren ,start-regex ,end-regex
                                beg end type count nil))
           (evil-define-text-object ,outer-name
             (count &optional beg end type)
             (evil-select-paren ,start-regex ,end-regex
                                beg end type count t))
           (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
           (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))
    (define-and-bind-text-object
      "line" "l" "^\\s-*" "\\s-*$")

    (define-and-bind-text-object
      "pipe" "|" "|" "|")

    (evil-define-text-object evil-inner-buffer (count &optional beg end type)
      (list (point-min) (point-max)))
    (general-def
      'evil-inner-text-objects-map
      "e" 'evil-inner-buffer)
    (general-def
      'evil-outer-text-objects-map
      "e" 'evil-inner-buffer)

    (setq evil-default-state 'normal
          evil-disable-insert-state-bindings t
          evil-move-beyond-eol t
          evil-cross-lines t)

    (setq evil-v$-gets-eol t)
    ;; stop `v$' from selecting newlines
    (evil-define-motion evil-end-of-line
      (count)
      "Move the cursor to the end of the current line.
      If COUNT is given, move COUNT - 1 lines downward first."
      :type inclusive
      (move-end-of-line count)
      (when evil-track-eol
        (setq temporary-goal-column most-positive-fixnum
              this-command 'next-line))
      (unless (and (evil-visual-state-p)
                   evil-v$-gets-eol)
        (evil-adjust-cursor)
        (when (eolp)
          ;; prevent "c$" and "d$" from deleting blank lines
          (setq evil-this-type 'exclusive))))

    (dolist (mode '(bluetooth-mode
                    exwm-mode
                    git-timemachine-mode
                    image-dired-display-image-mode
                    image-mode
                    Man-mode))
      (evil-set-initial-state mode 'emacs))

    (dolist (keymap '((dired-mode-map . nil)
                      (elfeed-search-mode-map . nil)
                      (exwm-mode-map . nil)
                      (image-mode-map . nil)
                      (info-mode-map . nil)
                      (lexic-mode-map . 'normal)
                      (Man-mode-map . nil)
                      (notmuch-search-mode-map . nil)
                      (notmuch-show-mode-map . nil)
                      (popup-menu-keymap . nil)))
      (add-to-list 'evil-overriding-maps keymap))

    (setq evil-buffer-regexps
          '(("^ \\*load\\*" . nil)
            ("^\\*elfeed.*\\*$" . nil)
            ("^\\*.*[Hh]elp.*\\*$". nil)
            ("^*Flycheck" . nil)
            ("^*info" . nil)
            ("^\\*xref" . nil)
            ("^\\*Messages\\*$" . nil)
            ("COMMIT_EDITMSG" . insert)))

    <<evil-org-config>>

    (use-package evil-surround
      :config
      (global-evil-surround-mode))

    (use-package evil-args
      :general
      (evil-inner-text-objects-map
       "a" 'evil-inner-arg)
      (evil-outer-text-objects-map
       "a" 'evil-outer-arg))

    (use-package evil-commentary
      :init (evil-commentary-mode))

    (general-create-definer evil-exchange-def
      :prefix "C-c x")

    (use-package evil-exchange
      :general
      (evil-exchange-def
        "x" 'evil-exchange
        "c" 'evil-exchange-cancel)
      :init
      (evil-exchange-install))

    :general
    (general-unbind
      :states 'insert
      "C-t"
      "C-p"
      "C-n"
      "C-r"
      "C-k"
      "C-e"
      "C-a"
      "C-y"
      "C-o"
      "C-w"
      "C-d")
    (general-def
      :states 'insert
      "M-o" 'evil-jump-backward
      "M-i" 'evil-jump-forward
      "C-v" 'rectangle-mark-mode)
    (general-unbind
      :states 'motion
      "C-e"
      "C-y"
      "RET"
      "TAB"
      "C-o"
      "C-b"
      "C-f"
      "C-]"
      "SPC")
    (general-def
      :states 'motion
      "$" '(lambda ()
             (interactive)
             (evil-end-of-line))
      "M-o" 'evil-jump-backward
      "M-i" 'evil-jump-forward
      "<f3>" 'evil-search-next
      "S-<f3>" 'evil-search-previous
      "p" 'evil-previous-line
      "n" 'evil-next-line)
    (general-unbind
      :states 'normal
      "C-n"
      "C-p"
      "C-r"
      "M-."
      "M-y"
      "C-."
      "DEL"
      "C-t"
      "q")
    (general-def
      :states 'normal
      "m" 'evil-record-macro
      "j" 'evil-join
      "J" 'my-join-line
      "k" 'evil-paste-after
      "K" 'evil-paste-before
      "U" 'evil-redo
      "C-w" 'whole-line-or-region-kill-region
      "<S-return>" 'my-evil-insert-line-below
      "<C-S-return>" 'my-evil-insert-line-above
      [remap evil-next-line] 'evil-next-visual-line
      [remap evil-previous-line] 'evil-previous-visual-line
      "n" 'evil-next-line
      "p" 'evil-previous-line
      "C-y" 'evil-paste-after
      "C-S-y" 'evil-paste-before
      "C-M-s-p" 'evil-paste-after
      "C-M-S-s-p" 'evil-paste-before)
    (general-def
      :states 'visual
      "s" 'evil-surround-region
      "k" 'evil-paste-after
      "K" 'evil-paste-before
      "C-w" 'whole-line-or-region-kill-region
      [remap evil-next-line]'evil-next-visual-line
      [remap evil-previous-line] 'evil-previous-visual-line)
    (general-unbind evil-ex-completion-map
      "C-a"
      "C-k")
    (general-def
      evil-emacs-state-map
      :start-maps t
      "C-z" 'evil-normal-state)
    (general-def
      "C-d" 'evil-scroll-down
      "C-u" 'evil-scroll-up
      "M-." 'evil-goto-definition
      [remap end-of-buffer]'evil-goto-line
      [remap beginning-of-buffer]'evil-goto-first-line
      [remap isearch-forward] 'evil-search-forward
      [remap isearch-backward] 'evil-search-backward
      [remap xref-find-definitions] 'evil-goto-definition
      [remap forward-paragraph] 'evil-forward-paragraph
      [remap backward-paragraph] 'evil-backward-paragraph))
#+END_SRC

** Org mode modifications

Using Evil mode in Org mode has highlighted a few things that need
to fixed. For instance, when inserting a new headline or item, I
/always/ want to start in insert mode.

#+name: evil-org-config
#+BEGIN_SRC emacs-lisp :tangle no
  (dolist (f '(org-insert-heading org-insert-item))
    (advice-add f :after (lambda (&rest _)
                           (evil-insert-state))))
#+END_SRC

* balanced windows
:PROPERTIES:
:REPO:     https://github.com/wbolster/emacs-balanced-windows
:END:


balanced-windows.el keeps your windows balanced whenever the
configuration changes.

#+BEGIN_SRC emacs-lisp
  (use-package balanced-windows
    :config
    (balanced-windows-mode))
#+END_SRC



* selectrum +++
:PROPERTIES:
:REPO:     https://github.com/raxod502/selectrum
:END:
:LOGBOOK:
- State "TODO"       from              [2021-01-15 Fri 14:11] \\
  For some reason, I can't seem to make this work properly. Try it out
  on NixOS and see what's up?
:END:


selectrum is a replacement for ivy/helm.

#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :general
    ('selectrum-minibuffer-map
     [remap evil-scroll-down] 'selectrum-next-page
     [remap evil-scroll-up] 'selectrum-previous-page)
    :init
    (setq selectrum-show-indices t)
    <<selectrum-additional-packages>>
    (selectrum-mode +1))
#+END_SRC


** Additional packages
:PROPERTIES:
:header-args: :noweb-ref selectrum-additional-packages :tangle no :results silent :comments both
:END:


In addition to the base selectrum package, there are a number of
other recommended packages that'll make improve it.


*** Prescient
:PROPERTIES:
:REPO:     https://github.com/raxod502/prescient.el
:END:

#+name: prescient-config
#+BEGIN_SRC emacs-lisp
  (use-package selectrum-prescient
    :config
    (selectrum-prescient-mode +1)
    (prescient-persist-mode +1))
#+END_SRC


*** TODO Consult
:PROPERTIES:
:REPO:     https://github.com/minad/consult
:END:
:LOGBOOK:
- State "TODO"       from              [2021-01-25 Mon 20:46] \\
  Make this work as expected with EXWM.

  Currently, when previewing buffers, if they are X-windows, then they
  are removed from their original position and not restored. This is
  bothersome. There is an [[https://github.com/muffinmad/emacs-mini-frame/pull/29][open PR]] that at least fixes something related
  to this, but I'm not sure how it affects everything as a whole.

  Further: it might be nice if X windows aren't moved at all?
:END:


#+name: consult-config
#+BEGIN_SRC emacs-lisp
  (use-package consult
    :after projectile
    :general
    ([remap repeat-complex-command] 'consult-complex-command
     [remap switch-to-buffer] 'consult-buffer
     [remap switch-to-buffer-other-window] 'consult-buffer-other-window
     [remap switch-to-buffer-other-frame] 'consult-buffer-other-frame
     [remap copy-to-register] 'consult-register
     [remap bookmark-jump] 'consult-bookmark
     [remap goto-line] 'consult-goto-line
     "M-g o" 'consult-outline
     "M-g l" 'consult-line
     "M-g m" 'consult-mark
     "M-g k" 'consult-global-mark
     "M-g r" 'consult-ripgrep
     "M-g f" 'consult-find
     "M-g e" 'consult-error
     "M-s m" 'consult-multi-occur
     "C-M-y" 'consult-yank-pop)

    :init
    (fset 'multi-occur #'consult-multi-occur)

    (setq register-preview-delay 0
          register-preview-function #'consult-register-preview)


    :config
    (setq consult-narrow-key "<"
          consult-project-root-function #'projectile-project-root
          consult-config `((consult-buffer :preview-key nil)))
    (defun consult-buffer-state-no-x ()
      "Buffer state function that doesn't preview X buffers."
      (let* ((orig-state (consult--buffer-state))
             (orig-buffer (buffer-name))
             (filter (lambda (cand restore)
                       (if (or restore
                               (when-let (buffer (and cand (get-buffer cand)))
                                 (not (eq 'exwm-mode (buffer-local-value 'major-mode buffer)))))
                           cand
                         orig-buffer))))
        (lambda (cand restore)
          (funcall orig-state (funcall filter cand restore) restore))))

    (setq consult--source-buffer
          (plist-put consult--source-buffer :state #'consult--buffer-state)))

  (use-package consult-flycheck
    :after flycheck
    :general
    (flycheck-command-map
     "!" 'consult-flycheck))
#+END_SRC


*** Marginalia
:PROPERTIES:
:REPO:     https://github.com/minad/marginalia
:END:

#+name: marginalia-config
#+BEGIN_SRC emacs-lisp
  (use-package marginalia
    :init
    (marginalia-mode)
    (advice-add #'marginalia-cycle :after
                (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))
    (setq marginalia-annotators '(marginalia-annotators-heavy
                                  marginalia-annotators-light
                                  nil))
    :general
    (minibuffer-local-map
     "C-M-a" 'marginalia-cycle)
    (embark-general-map
     "A" 'marginalia-cycle)
    )
#+END_SRC



*** Embark
:PROPERTIES:
:REPO:     https://github.com/oantolin/embark/
:END:


#+name: embark-config
#+BEGIN_SRC emacs-lisp
  (use-package embark
    :general
    ("C-c ?" 'embark-act)
    (minibuffer-local-map
     "C-c ?" 'embark-no-exit)
    :config
    (defun current-candidate+category ()
      (when selectrum-active-p
        (cons (selectrum--get-meta 'category)
              (selectrum-get-current-candidate))))

    (add-hook 'embark-target-finders #'current-candidate+category)

    (defun current-candidates+category ()
      (when selectrum-active-p
        (cons (selectrum--get-meta 'category)
              (selectrum-get-current-candidates minibuffer-completing-file-name))))

    (add-hook 'embark-candidate-collectors #'current-candidates+category)

    (add-hook 'embark-setup-hook 'selectrum-set-selected-candidate)

    ;; which-key integration
    (setq embark-action-indicator
          (lambda (map)
            (which-key--show-keymap "Embark" map nil nil 'no-paging)
            #'which-key--hide-popup-ignore-command)
          embark-become-indicator embark-action-indicator)

    (use-package embark-consult
      :hook
      (embark-collect-mode . embark-consult-preview-minor-mode)))
#+END_SRC


*** TODO emacs-mini-frame
:PROPERTIES:
:REPO:     https://github.com/muffinmad/emacs-mini-frame
:END:
:LOGBOOK:
- State "TODO"       from              [2021-01-25 Mon 20:48] \\
  Make this work properly with EXWM. In particular, make the mini frame
  show on top of X windows and make it not lose focus when an X-window
  is previewed.
:END:

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref nop
  (use-package mini-frame
    :unless (string= "t" (getenv "SUPPRESS_MINI_FRAME"))
    :custom
    (mini-frame-show-parameters '((top . 0.3)
                                  (width . 0.7)
                                  (left . 0.5)
                                  (height . 1)))
    :config
    (setq mini-frame-standalone t)
    :init
    (mini-frame-mode))
#+END_SRC


* CTRLF
:PROPERTIES:
:REPO:     https://github.com/raxod502/ctrlf
:END:

CTRLF is a replacement/improvement over standard isearch.

#+BEGIN_SRC emacs-lisp
  (use-package ctrlf
    :disabled
    :config
    (ctrlf-mode +1))
#+END_SRC

* flyspell additions

** TODO flyspell-correct
:PROPERTIES:
:REPO:     https://github.com/d12frosted/flyspell-correct
:END:
:LOGBOOK:
- State "TODO"       from              [2021-02-05 Fri 10:46] \\
  Look into this. I can't seem to accept any suggestions from the popup
  and I'm not sure why.
:END:


#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct
    :after flyspell
    :general
    (flyspell-mode-map
     "C-;" 'flyspell-correct-wrapper
     "C-." 'flyspell-correct-at-point
     "C-," 'flyspell-correct-next))
#+END_SRC


*** flyspell-correct-popup

This package offers a popup menu for the flyspell-correct
suggestions. Because Evil (and my binding of ~<return>~) causes
some issues with selection in normal mode, we also add an explicit
mapping of ~popup-select~.

#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct-popup
    :general
    (popup-menu-keymap
     "<return>" 'popup-select)
    :after flyspell-correct)
#+END_SRC

* Writegood mode
:PROPERTIES:
:REPO:     https://github.com/bnbeckwith/writegood-mode
:END:


Writegood mode helps me keep my writing clearer and more concise.

#+BEGIN_SRC emacs-lisp
  (use-package writegood-mode
    :hook
    (markdown-mode . writegood-mode)
    (org-mode . writegood-mode))
#+END_SRC



* flycheck-aspell
:PROPERTIES:
:REPO:     https://github.com/leotaku/flycheck-aspell
:END:


#+BEGIN_SRC emacs-lisp
  (use-package flycheck-aspell
    :init
    (setq ispell-dictionary "english"
          ispell-program-name "aspell"
          ispell-silently-savep t)
    (dolist (checker '(mail-aspell-dynamic
                       tex-aspell-dynamic
                       html-aspell-dynamic
                       markdown-aspell-dynamic
                       nroff-aspell-dynamic
                       texinfo-aspell-dynamic
                       xml-aspell-dynamic))
      (add-to-list 'flycheck-checkers checker))
    :config
    (defun flycheck-maybe-recheck (_)
      (when (bound-and-true-p flycheck-mode)
        (flycheck-buffer)))
    (advice-add #'ispell-pdict-save :after #'flycheck-maybe-recheck))
#+END_SRC



* TODO lexic
:PROPERTIES:
:REPO:     https://github.com/tecosaur/lexic
:END:
:LOGBOOK:
- State "TODO"       from              [2021-02-24 Wed 08:51] \\
  Make this work. For now, Straight fails when trying to clone it. I
  don't know why.
:END:


#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lexic)
#+END_SRC

* Git clone url

Based on [[http://xenodium.com/emacs-clone-git-repo-from-clipboard/][this post]] about automating repo cloning from clipboard,
let's create a workflow better suited to our usage.

#+BEGIN_SRC emacs-lisp
  (defun heartman/git-clone-clipboard-url (project-parent-dir)
    "Clone the git URL in the clipboard and open in dired."
    (interactive
     (progn
       (cl-assert (string-match-p "^\\(\\(https?\\|ssh\\)://\\|git@\\)" (current-kill 0)) nil "No URL in clipboard")
       (list
        (completing-read "Which directory to use: "
                         (my-project-paths)))))
    (let* ((url (current-kill 0))
           (parent-dir (file-name-as-directory (expand-file-name project-parent-dir)))
           (repo-name (file-name-base url))
           (project-dir (concat parent-dir repo-name))
           (command (format "git clone %s %s" url project-dir))
           (buffer (generate-new-buffer (format "*%s*" command)))
           (proc))
      (when (file-exists-p project-dir)
        (if (y-or-n-p (format "Directory %s already exists. Do you want to delete it?" project-dir))
            (delete-directory project-dir t)
          (user-error "Aborting. The target directory exists and you have decided not to overwrite it")))
      (setq proc (start-process-shell-command (car (split-string command))
                                              buffer
                                              command))
      (message "Running: %s" command)
      (with-current-buffer buffer
        (shell-command-save-pos-or-erase)
        (require 'shell)
        (shell-mode)
        (view-mode +1))
      (set-process-sentinel
       proc
       (lambda (process state)
         (let ((output (with-current-buffer (process-buffer process)
                         (buffer-string))))
           (kill-buffer (process-buffer process))
           (if (= (process-exit-status process) 0)
               (progn
                 (message "Finished: %s " command)
                 (dired project-dir))
             (user-error (format "%s\n%s" command output))))))

      (set-process-filter proc #'comint-output-filter)))
#+END_SRC

* Open google meet link in chromium

Google meet links work much better in Chromium than in Firefox, so
let's create a function to open those urls in chromium if you have one
in the clipboard.

#+BEGIN_SRC emacs-lisp
  (defun heartman/open-google-meet-link-in-chromium (meet-link)
    "Clone the git URL in the clipboard and open in dired."
    (interactive
     (save-match-data
       (cl-assert
        (string-match
         "\\b\\(\\(https://\\)?meet.google.com/.+\\)\\b"
         (current-kill 0))
        nil
        "No meet link found in clipboard")
       (list (match-string 1 (current-kill 0)))))
    (browse-url-chromium meet-link))
#+END_SRC


* adoc-mode
:PROPERTIES:
:REPO:     https://github.com/sensorflo/adoc-mode
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2021-05-03 Mon 10:10]
- State "TODO"       from              [2021-05-03 Mon 09:51] \\
  Make the 'open browser in other window functionality work.'
:END:

Adoc-mode requires the markup-faces package, so let's install that too.

#+BEGIN_SRC emacs-lisp
  (use-package markup-faces)
#+END_SRC

Additionally: the markup-faces package includes some pretty massive
font sizes, so let's just normalize them to be regular height.

#+BEGIN_SRC emacs-lisp
  (defun heartman/open-file-in-browser (open-in-new-window)
    "Open the current file in your preferred web browser.

  If the buffer is visiting a directory or something else that is
  not a file, open `default-directory' instead."
    (interactive "P")
    (let* ((file (buffer-file-name))
           (target (if (and file (f-file-p file))
                       file
                     default-directory))
           (window (if open-in-new-window
                       (funcall split-window-preferred-function)
                     (selected-window))))
      (select-window window)
      (browse-url target)))

  (defun heartman/toggle-adoc-source-note ()
    "Add or remove an adoc comment to the end of the current line."
    (interactive)
    (let ((comment "<--.-->"))
      (save-excursion
        (end-of-line)
        (if (looking-back "<--\.--> *")
            (progn
              (while (not (looking-at "<"))
                (backward-char))
              (delete-char (length comment)))
          (insert (format " %s" comment))))))

  (use-package adoc-mode
    :after markup-faces
    :general
    (adoc-mode-map
     "C-c C-s" 'heartman/open-file-in-browser
     "C-c C-c" 'heartman/toggle-adoc-source-note)
    :hook
    (adoc-mode . (lambda () (auto-fill-mode -1)))
    (adoc-mode . writegood-mode)
    :init
    (dolist (i (number-sequence 0 5))
      (set-face-attribute
       (intern (format "markup-title-%d-face" i))	nil :height 1.0))
    :mode "\\.adoc\\'")
#+END_SRC

* asciidoc

#+BEGIN_SRC emacs-lisp
  (use-package asciidoc)
#+END_SRC



** doc-mode

#+BEGIN_SRC emacs-lisp
  (use-package doc-mode
    :hook
    (doc-mode . (lambda ()
                  (turn-on-auto-fill)
                  (require 'asciidoc))))
#+END_SRC

* TODO lsp-grammarly
:PROPERTIES:
:REPO:     https://github.com/emacs-grammarly/lsp-grammarly
:END:
:LOGBOOK:
- State "TODO"       from              [2021-03-17 Wed 11:54] \\
  This would be cool if it worked. However, the language server is
  distributed as an npm package which is not available in nixpkgs at the
  moment. It may be possible to use [[https://github.com/svanderburg/node2nix][node2nix]] to create an overlay
  somehow (or look at how things are built in [[https://raw.githubusercontent.com/NixOS/nixpkgs/master/pkgs/development/node-packages/node-packages.nix][nixpkgs.nodePackages]]), but
  this would require some work.
:END:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-grammarly
    ;; :hook
    ;; (text-mode . lsp)
    )
#+END_SRC

* screenshot.el
:PROPERTIES:
:REPO:     https://github.com/tecosaur/screenshot
:END:


#+BEGIN_SRC emacs-lisp
  (use-package screenshot
    :straight `(screenshot
                :type git
                :host github
                :repo "tecosaur/screenshot"))
#+END_SRC



* Go-mode
:PROPERTIES:
:REPO:     https://github.com/dominikh/go-mode.el
:END:

#+BEGIN_SRC emacs-lisp
  (use-package go-mode)
#+END_SRC

* org-pandoc-import
:PROPERTIES:
:REPO:     https://github.com/tecosaur/org-pandoc-import
:END:

#+BEGIN_SRC emacs-lisp
  (use-package org-pandoc-import
    :straight (:host github
                     :repo "tecosaur/org-pandoc-import"
                     :files ("*.el" "filters" "preprocessors")))
#+END_SRC



* mixed-pitch
:PROPERTIES:
:REPO:     https://gitlab.com/jabranham/mixed-pitch
:END:

#+BEGIN_SRC emacs-lisp
  (use-package mixed-pitch
    :hook
    (text-mode . mixed-pitch-mode)
    (org-mode . mixed-pitch-mode)
    (adoc-mode . mixed-pitch-mode)
    (notmuch-show-mode . mixed-pitch-mode)
    (notmuch-search-mode . mixed-pitch-mode)
    (notmuch-hello-mode . mixed-pitch-mode))
#+END_SRC

* Olivetti
:PROPERTIES:
:REPO:     https://github.com/rnkn/olivetti
:END:

#+BEGIN_SRC emacs-lisp
  (defun heartman/olivetti-hide-fringes ()
    "Hide fringes when using olivetti."
    (set-window-fringes (selected-window)
                        nil nil t t))

  (use-package olivetti
    :custom
    (olivetti-body-width 80)
    :general
    (general-unbind
      'olivetti-mode-map
      "C-c |")
    :hook
    ((text-mode
      Info-mode
      help-mode
      Custom-mode
      notmuch-show-mode
      notmuch-hello-mode) . olivetti-mode)
    (nxml-mode . (lambda () (olivetti-mode -1)))
    (olivetti-mode-on . heartman/olivetti-hide-fringes))
#+END_SRC

* auctex

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package auctex)
#+END_SRC


* cdlatex.el

cdlatex mode adds some really nice quality of life things when working
with latex. However, the ~cdlatex-pbb~ function seems to not work
properly (potentially in conjunction with smartparens?), so it doesn't
insert a closing parenthesis. So we'll unbind that mapping from a
number of delimiters and let smartparens handle that.

#+BEGIN_SRC emacs-lisp
  (use-package cdlatex
    :after smartparens
    :hook
    (LaTeX-mode . cdlatex-mode)
    (TeX-latex-mode . cdlatex-mode)
    :general
    (general-unbind
      'cdlatex-mode-map
      "{" "(" "<" "[")
    :config
    (sp-local-pair 'org-cdlatex-mode "$" "$"))
#+END_SRC

* shellcheck
:PROPERTIES:
:REPO:     https://github.com/federicotdn/flymake-shellcheck
:END:

#+BEGIN_SRC emacs-lisp
  (use-package flymake-shellcheck)
#+END_SRC

* winum
:PROPERTIES:
:REPO:     https://github.com/deb0ch/emacs-winum
:END:


#+BEGIN_SRC emacs-lisp
  (use-package winum
    :init
    (winum-mode)
    :custom
    (winum-scope 'visible)
    :config
    (defun heartman/update-winum (&rest args)
      (winum--update)
      args)

    (advice-add 'tab-bar-select-tab :filter-return #'heartman/update-winum))
#+END_SRC

* XML (nxml-mode)

#+BEGIN_SRC emacs-lisp
  (use-package emacs
    :hook
    (nxml-mode . emmet-mode)
    (nxml-mode . lsp)
    :init
    (setq nxml-slash-auto-complete-flag t))
#+END_SRC

* graphql

** graphql-mode
:PROPERTIES:
:REPO:     https://github.com/davazp/graphql-mode
:END:

#+BEGIN_SRC emacs-lisp
  (use-package graphql-mode
    :init
    (use-package request))
#+END_SRC


** ob-graphql
:PROPERTIES:
:REPO:     https://github.com/jdormit/ob-graphql
:END:

#+BEGIN_SRC emacs-lisp
  (use-package ob-graphql
    :init (add-to-list 'org-babel-load-languages '(graphql . t)))
#+END_SRC

* groovy-mode
:PROPERTIES:
:REPO:     https://github.com/Groovy-Emacs-Modes/groovy-emacs-modes
:END:

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode)
#+END_SRC

* rich-minority
:PROPERTIES:
:REPO:     https://github.com/Malabarba/rich-minority
:END:

rich-minority enables us to hide all minor modes from the mode line.

#+BEGIN_SRC emacs-lisp
  (use-package rich-minority
    :init
    (rich-minority-mode)
    :custom
    (rm-blacklist ""))
#+END_SRC

* Matrix client
:PROPERTIES:
:REPO:     https://github.com/alphapapa/matrix-client.el
:END:

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package matrix-client
    :straight (:host github
                     :repo "alphapapa/matrix-client.el"))
#+END_SRC

* Bluetooth
:PROPERTIES:
:REPO:     https://gitlab.com/rstocker/emacs-bluetooth
:END:

#+BEGIN_SRC emacs-lisp
  (use-package bluetooth)
#+END_SRC

* Java

** lsp
:PROPERTIES:
:REPO:     https://github.com/emacs-lsp/lsp-java
:END:

#+BEGIN_SRC emacs-lisp
  (use-package lsp-java
    :hook (java-mode . lsp))
#+END_SRC
